<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.96.0" /><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My-Thistledown</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://fang-lansheng.github.io/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://fang-lansheng.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://fang-lansheng.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fang-lansheng.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://fang-lansheng.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://fang-lansheng.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://fang-lansheng.github.io/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="My-Thistledown" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://fang-lansheng.github.io/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="My-Thistledown"/>
<meta name="twitter:description" content=""/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "My-Thistledown",
  "url": "https://fang-lansheng.github.io",
  "description": "",
  "thumbnailUrl": "https://fang-lansheng.github.io/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fang-lansheng.github.io" accesskey="h" title="My-Thistledown (Alt + H)">My-Thistledown</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2>机器学习-吴恩达：学习笔记及总结（3）
    </h2>
  </header>
  <section class="entry-content">
    <p>Course Link ：Week 3 - Logistic Regression
Code : Fang-Lansheng/Coursera-MachineLearning-Python
 7 Classification and Representation 7.1 Classification   The classification problem is just like the regression problem, except that the values we now want to predict take on only a small number of discrete values.
  For now, we will focus on the binary classification problem.
  $y \in {0,1}$ - the variable that we’re trying to predict...</p>
  </section>
  <footer class="entry-footer"><span title='2020-03-04 00:00:00 +0000 UTC'>March 4, 2020</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to 机器学习-吴恩达：学习笔记及总结（3）" href="https://fang-lansheng.github.io/posts/2020-03-04-ml-ng-3/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>机器学习-吴恩达：学习笔记及总结（2）
    </h2>
  </header>
  <section class="entry-content">
    <p>Course Link ：Week 2 - Linear Regression with Multiple Variables
Code : Fang-Lansheng/Coursera-MachineLearning-Python
 5. Multivariate Linear Regression 5.1 Multiple Features  Training set:  Notation:  $m$ = the number of training examples $n$ = number of features $x^{(i)}$ = input (features) of $i^{th}$ training example (an $n$-dimensional vector, $i = 1, 2, \cdots, m$). $x_j^{(i)}$ = value of feature $j$ in $i^{th}$ training example (a number, $j = 1, 2, \cdots, n$)....</p>
  </section>
  <footer class="entry-footer"><span title='2020-02-28 00:00:00 +0000 UTC'>February 28, 2020</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to 机器学习-吴恩达：学习笔记及总结（2）" href="https://fang-lansheng.github.io/posts/2020-02-26-ml-ng-2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>机器学习-吴恩达：学习笔记及总结（1）
    </h2>
  </header>
  <section class="entry-content">
    <p>Course Link ：Week 1 - Introduction
Code : Fang-Lansheng/Coursera-MachineLearning-Python
 0. 写在课前  作为机器学习入门课程中的经典，吴恩达教授的课程具有如下特点：  数学推导过程少，偏重基础，门槛较低 课程短小精悍，讲解清晰，覆盖面广 主要用 Matlab 完成课后程序作业   课程学习目标：  理解机器学习的基本思想和方法 用 Python 实现课程要求掌握的算法    1. Introduction 1.1 Welcome   Machine Learning
 Grew out of work in AI New capability for computers    Examples:
  Database mining
  Large datesets from growth of automation/web
E.g., Web click data, medical records, biology, engineering...</p>
  </section>
  <footer class="entry-footer"><span title='2020-02-26 00:00:00 +0000 UTC'>February 26, 2020</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to 机器学习-吴恩达：学习笔记及总结（1）" href="https://fang-lansheng.github.io/posts/2020-02-26-ml-ng-1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>OpenCV——SIFT 算法及源码分析（1）：原理简介
    </h2>
  </header>
  <section class="entry-content">
    <p>本文及接下来几篇同系列文章是学习 SIFT 算法和 OpenCV SIFT 源码时的学习笔记，整合自参考文献及博客。强烈建议阅读 论文原文、GitHub上的源码 以及 @赵春江 的 opencv 2.4.9 源码分析。
 Lowe 在 2004 年提出了尺度不变特征变换 (Scale Invariant Feature Transform, SIFT) 算法。 SIFT 主要由关键点探测器 (detector) 和描述符 (descriptor) 组成，它的实现分为以下四步:
 尺度空间极值探测 (scale-space extrema detection)：通过高斯差分函数搜索所有尺度和图像位置，以识别对于尺度和方向不变的潜在兴趣点。 关键点精确定位 (keypoint localization)：精确确定每个候选点的尺度与亚像素级位置，根据其稳定性阈值选择关键点。 方向分配 (orientation assignment)：基于图像的局部梯度方向，为每个特性点分配一个或多个方向角度。所有后续的操作都是相对于所确定下来的特征点的角度、尺度和位置的基础上进行的，因此特征点具有角度、尺度和位置的不变性。 关键点描述符 (keypoint descriptor)：在所选定的尺度空间内，测量特征点邻域区域的局部图像梯度，将这些梯度转换成一种允许局部较大程度的形状变形和亮度变化的描述符形式。  下面将对其进行详细阐释：
1. 尺度空间极值探测 关键点检测的第一阶段是识别可以在同一对象的不同视图下重复分配的位置和尺度。通过在素有可能的尺度进行搜索，可以检测出对图像尺度不变的稳定特征。这一过程中使用到的是被称为尺度空间 (scale space) 的尺度连续函数^[1]。
Koenderink (The structure of images, 1984) 和 Lindeberg (Detecting salient blob-like image structures and their scales with a scale-space primal sketch: A method for focus-of-attention, 1993) 已经证明，唯一可能的尺度空间核是高斯函数。因此，图像的尺度空间被定义为函数 $L(x, y, \sigma)$，它是由可变尺度高斯函数 $G(x, y, \sigma)$ 与输入图像 $I(x,y)$ 卷积得到的：...</p>
  </section>
  <footer class="entry-footer"><span title='2019-05-10 00:00:00 +0000 UTC'>May 10, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to OpenCV——SIFT 算法及源码分析（1）：原理简介" href="https://fang-lansheng.github.io/posts/2019-05-10-opencv-4/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>OpenCV——相机检校
    </h2>
  </header>
  <section class="entry-content">
    <p>本文主要参考自 OpenCV 官方教程 OpenCV: Camera calibration With OpenCV，大部分内容是对原文的直接翻译。
 1. 前言 利用手机相机对棋盘图拍摄得到的图像如下（左边为原图，右边为二值化处理后的图像）：
如下所示，将其与原始棋盘图对比（左侧为原始图像，右侧为手机相机拍摄影像）。可以明显地看出出现了一定程度的畸变。
2. 相机检校原理 目前常用的相机检校方法是附加参数法，其关键在于通过一组额外参数拟合镜头畸变，主要是径向畸变和切向畸变：
$$ \begin{align} dx &amp;= x(k_1r^2&#43;k_2r^4&#43;k_3r^6) &#43; p_1(r^2&#43;2x^2) &#43; p_2xy \ dy &amp;= \underbrace{y(k_1r^2&#43;k_2r^4&#43;k_3r^6)}\text{radial distortion} &#43; \underbrace{p_2(r^2&#43;2y^2) &#43; p_1xy}\text{tangential distortion} \end{align} $$
式中，
$$ x=x’-x_0, \quad y=y’-y_0 \ r^2 = x^2 &#43; y^2 $$
其中 $(x’,y’)$ 为像片坐标的原始量测值，$k_i,(i=1,2,3)$ 为径向畸变参数，$p_j, (j=1,2)$ 为切向畸变参数。所以 5 个畸变参数构成的矩阵为：
$$ distortion_coeffients = (\begin{matrix}k_1&amp;k_2&amp;p_1&amp;p_2&amp;k_3\end{matrix}) $$
对于影像坐标和物空间坐标的转换关系为：
$$ \begin{bmatrix}x\y\f\end{bmatrix}= K \begin{bmatrix}X\Y\Z\end{bmatrix}= \begin{bmatrix}f_x&amp;0&amp;c_x\0&amp;f_y&amp;c_y\0&amp;0&amp;1\end{bmatrix} \begin{bmatrix}X\Y\Z\end{bmatrix} $$...</p>
  </section>
  <footer class="entry-footer"><span title='2019-04-18 00:00:00 +0000 UTC'>April 18, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to OpenCV——相机检校" href="https://fang-lansheng.github.io/posts/2019-04-18-opencv-3/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>线性代数——特征值分解、奇异值分解与 RQ 分解
    </h2>
  </header>
  <section class="entry-content">
    <p>特征值分解 1. 特征值与特征向量 在线性代数中，对于 $n$ 阶方阵 $A$，如果存在某个数 $\lambda$ 及某个 $n$ 维非零列向量 $v$，使得
$$ Av = \lambda v $$
则称 $\lambda$ 是方阵 $A$ 的一个特征值，$v$ 是方阵 $A$ 的属于特征值 $\lambda$ 的一个特征向量。
对上式进行变换：
$$ \begin{align} Av-\lambda v &amp;= \overrightarrow{0} \ Av-\lambda I v &amp;= \overrightarrow{0} \ (A - \lambda I)v &amp;= \overrightarrow{0} \ (\lambda I - A)v &amp;= \overrightarrow{0} \end{align} $$
则称
 $\lambda E - A$ 为 $A$ 的特征矩阵 行列式 $f(\lambda) = |\lambda E- A|$ 为 $A$ 的特征多项式 $|\lambda E - A| = 0$ 是 $A$ 的特征方程 $(\lambda E - A)v = \overrightarrow{0}$ 是 $A$ 关于该特征值 $\lambda$ 的齐次线性方程组  $A$ 的主对角线上元素之和称为矩阵的迹（trace），记为 $tr(A)$，即...</p>
  </section>
  <footer class="entry-footer"><span title='2019-04-12 00:00:00 +0000 UTC'>April 12, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to 线性代数——特征值分解、奇异值分解与 RQ 分解" href="https://fang-lansheng.github.io/posts/2019-04-12-math-1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>OpenCV——点特征提取算子：Moravec，Forstner 与 Harris
    </h2>
  </header>
  <section class="entry-content">
    <p>在计算机视觉（Computer Vision）与摄影测量（Photogrammetry）中，我们在不同影像之间找到相匹配的特征，已建立两幅影像之间的联系，提取出我们所需要的信息。这些特征主要分为：
 边缘（Edges） 角点（Corners） 兴趣区域 ROI（Regions of Interest）  其中，提取点特征的算子称为兴趣算子或有利算子（Interest Operator），即运用某种算法从影像种提取我们感兴趣的、有利于某种目的的点。
人眼对角点的识别通常是在一个局部的小区域或小窗口内完成的。如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。如果这个特定的窗口在图像各个方面移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么窗口内的图像可能只是一条直线的线段。
角点的特殊之处在于，它是两条边的交点，所以它代表这两条边的方向发生变化的点。因此，图像在该点的梯度（在各个方向上）具有明显的变化。利用这一点，前人提出了一系列算法，其中比较经典的有 Moravec 算子、Forstner 算子以及 Harris 算子等。
Moravec 算子 基本原理 Moravec 于 1977 年提出利用灰度方差提取点特征的算子，其步骤为：
1. 计算各像元的兴趣值 $IV$（Interest Value）。 在以像素 $(c, r)$ 为中心的 $w \times w$ 的窗口中（如 $5 \times 5$ 的窗口），计算四个方向相邻像素灰度差的平方和：
$$ \begin{cases} V_1 &amp;=&amp; \sum_{i = -k}^{k-1}(g_{c&#43;i,r}-g_{c&#43;i&#43;1, r})^2 \[2ex] V_2 &amp;=&amp; \sum_{i = -k}^{k-1}(g_{c&#43;i,r&#43;i}-g_{c&#43;i&#43;1, r&#43;i&#43;1})^2 \[2ex] V_3 &amp;=&amp; \sum_{i = -k}^{k-1}(g_{c,r&#43;i}-g_{c&#43;i&#43;1, r&#43;i&#43;1})^2 \[2ex] V_4 &amp;=&amp; \sum_{i = -k}^{k-1}(g_{c&#43;i,r-i}-g_{c&#43;i&#43;1, r-i-1})^2 \end{cases} $$...</p>
  </section>
  <footer class="entry-footer"><span title='2019-04-02 00:00:00 +0000 UTC'>April 2, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to OpenCV——点特征提取算子：Moravec，Forstner 与 Harris" href="https://fang-lansheng.github.io/posts/2019-04-02-opencv-2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>OpenCV——内置边缘检测算子：Canny，Sobel 与 Laplace
    </h2>
  </header>
  <section class="entry-content">
    <p>边缘检测（Edge Detection）是图像处理的基础内容。本文中，我从OpenCV官网上下载了最新版本的 OpenCV 4.0.1（2018-12-22），借助官方文档和网络教程完成了环境配置与测试，具体步骤不再赘述。
在 OpenCV 中可用于边缘检测的算子主要有：
 Canny 算子 Sobel 算子 Laplace 算子   Canny 算子 理论 Canny 算法是由 John F. Canny 于 1987 年在 A computational approach to edge detection 一文提出来的，它旨在满足三个主要标准：
 **低错误率（Low error rate）：**意味着只检测实际存在的边缘。 **高定位性（Good localization）：**将检测到的边缘像素与实际边缘像素之间的距离最小化。 **最小响应（Minimal response）：**每个边缘只有一个检测器响应。  Canny 算子的步骤如下：
 滤掉任何噪声。这一过程将使用高斯滤波器。例如，一个 5×5 的高斯内核如下所示：  $$ K = \dfrac{1}{159}\begin{bmatrix} 2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \ 4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \ 5 &amp; 12 &amp; 15 &amp; 12 &amp; 5 \ 4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \ 2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \end{bmatrix} $$...</p>
  </section>
  <footer class="entry-footer"><span title='2019-03-19 00:00:00 +0000 UTC'>March 19, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to OpenCV——内置边缘检测算子：Canny，Sobel 与 Laplace" href="https://fang-lansheng.github.io/posts/2019-03-19-opencv-1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>PAT Advanced Level Practice (I)
    </h2>
  </header>
  <section class="entry-content">
    <p>PAT Advanced Level 刷题（一）
PTA | 程序设计类实验辅助教学平台
 PAT A 1025 解题思路
题目大意为：有 N（≤100） 个考场，每个考场有若干数量（K≤300）的考生。现给出各个考场中考生的准考证号与分数，要求将所有考生按分数从高到低排序，并按顺序输出所有考生的准考证号、排名、考场号及考场内排名。
题目要求的信息（准考证号、分数等）可以用结构体 Student 来存放。对考生进行排序可以使用 C&#43;&#43; 标准库中的 sort() 函数，题目中指出结果应按照考生排名递增排序，相同分数的考生排名相同且按照准考证号递增排序。因此，我们需要准们编写一个符合题目条件的 cmp 函数，它应该满足如下规则：
 当分数不同时，按分数从大到小排序 否则，按准考证号从小到大排序。  也即：
bool cmp(Student a, Student b) {  if (a.score != b.score)  return a.score &gt; b.score; // 先按分数从高到低排序  else  return strcmp(a.id, b.id) &lt; 0;	// 若分数相同，则按准考证号从小到大排序 } 算法本身分为三步：
 按考场读入各考生的信息，并对当前读入考场的所有考生进行排序。之后将该考场的所有考生的排名写入其结构体中。 对所有考生进行排序 按照排序，一遍计算总排名，一遍输出信息  参考代码
#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt; using namespace std;  struct Student {  char id[15];	// 准考证号  int score;	// 分数  int location_number;	// 考场号  int local_rank;	// 考场内排名 }stu[30010];  bool cmp(Student a, Student b) { 	if (a....</p>
  </section>
  <footer class="entry-footer"><span title='2019-03-16 00:00:00 +0000 UTC'>March 16, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to PAT Advanced Level Practice (I)" href="https://fang-lansheng.github.io/posts/2019-03-16-pat-a-1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>数据结构——求解斐波那契数列算法的复杂度
    </h2>
  </header>
  <section class="entry-content">
    <p>斐波那契数列 斐波那契数列（Fibonacci Sequence）是一串数字：
\[ (0,) 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, … \] 很容易看出，每一个数（除第 1、2 个）都等于它之前的两个数之和。因此，用公式可归纳为： \[ F_n = \begin{cases} 0, &amp; n=0 \\ 1, &amp; n=1 \\ F_{n-1} &#43; F_{n-2}, &amp; n&gt;1 \end{cases} \]
计算复杂性理论 在将斐波那契数列用 C&#43;&#43; 代码实现并计算时间、空间复杂度之前，先要了解一下什么是所谓的“复杂度”
时间复杂度  在计算机科学中， 算法的时间复杂度（Time Complexity）是一个函数，它定性描述算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。
 一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和即为 $T(n)$，它是该算法问题规模 $n$ 的函数，时间复杂度主要分析 $T(n)$ 的数量级。 算法的基本运算（最深层循环内的语句）的频度与 $T(n)$ 同数量级。因此通常采用算法中基本运算的频度 $f(n)$ 来分析算法的时间复杂度。因此，算法的时间复杂度记为： \[ T(n) = O(f(n)) \] 式中，$O$ 的含义是 $T(n)$ 的数量级，其严格的数学定义是：若 $T(n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数，则存在正常数 $C$ 和 $n_0$，使得当 $n \geq n_0$ 时，都满足 $0 \leq T(n) \leq Cf(n)$。...</p>
  </section>
  <footer class="entry-footer"><span title='2019-03-01 00:00:00 +0000 UTC'>March 1, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to 数据结构——求解斐波那契数列算法的复杂度" href="https://fang-lansheng.github.io/posts/2019-03-01-ds-1/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://fang-lansheng.github.io/">« Prev Page</a>
    <a class="next" href="https://fang-lansheng.github.io/page/3/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://fang-lansheng.github.io">My-Thistledown</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
