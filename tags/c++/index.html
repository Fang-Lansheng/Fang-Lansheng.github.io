<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C&#43;&#43; | Jifan&#39;s Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="Jifan&#39;s Blog - https://jifan.tech">
<meta name="author" content="Jifan">
<link rel="canonical" href="https://jifan.tech/tags/c&#43;&#43;/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.fde654b260e1f519b54075caf2e98b3aa4c2feaaa6d43a82b19a4867c5bc423e.css" integrity="sha256-/eZUsmDh9Rm1QHXK8umLOqTC/qqm1DqCsZpIZ8W8Qj4=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jifan.tech/imgs/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jifan.tech/imgs/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jifan.tech/imgs/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jifan.tech/imgs/apple-touch-icon.png">
<link rel="mask-icon" href="https://jifan.tech/imgs/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://jifan.tech/tags/c&#43;&#43;/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="C&#43;&#43;" />
<meta property="og:description" content="Jifan&#39;s Blog - https://jifan.tech" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://jifan.tech/tags/c&#43;&#43;/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;"/>
<meta name="twitter:description" content="Jifan&#39;s Blog - https://jifan.tech"/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jifan.tech" accesskey="h" title="Jifan&#39;s Blog (Alt + H)">Jifan&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jifan.tech/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>C&#43;&#43;</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV 源码分析：SIFT 算法原理与实现
    </h2>
  </header>
  <section class="entry-content">
    <p>本文及接下来几篇同系列文章是学习 SIFT 算法和 OpenCV SIFT 源码时的学习笔记，整合自参考文献及博客。强烈建议阅读 论文原文、GitHub上的源码 以及 @赵春江 的 opencv 2.4.9 源码分析。
 1. SIFT 算法原理 Lowe 在 2004 年提出了尺度不变特征变换 (Scale Invariant Feature Transform, SIFT) 算法。 SIFT 主要由关键点探测器 (detector) 和描述符 (descriptor) 组成，它的实现分为以下四步:
 尺度空间极值探测 (scale-space extrema detection)：通过高斯差分函数搜索所有尺度和图像位置，以识别对于尺度和方向不变的潜在兴趣点。 关键点精确定位 (keypoint localization)：精确确定每个候选点的尺度与亚像素级位置，根据其稳定性阈值选择关键点。 方向分配 (orientation assignment)：基于图像的局部梯度方向，为每个特性点分配一个或多个方向角度。所有后续的操作都是相对于所确定下来的特征点的角度、尺度和位置的基础上进行的，因此特征点具有角度、尺度和位置的不变性。 关键点描述符 (keypoint descriptor)：在所选定的尺度空间内，测量特征点邻域区域的局部图像梯度，将这些梯度转换成一种允许局部较大程度的形状变形和亮度变化的描述符形式。  下面将对其进行详细阐释：
1.1 尺度空间极值探测 关键点检测的第一阶段是识别可以在同一对象的不同视图下重复分配的位置和尺度。通过在素有可能的尺度进行搜索，可以检测出对图像尺度不变的稳定特征。这一过程中使用到的是被称为尺度空间 (scale space) 的尺度连续函数^[1]。
Koenderink (The structure of images, 1984) 和 Lindeberg (Detecting salient blob-like image structures and their scales with a scale-space primal sketch: A method for focus-of-attention, 1993) 已经证明，唯一可能的尺度空间核是高斯函数。因此，图像的尺度空间被定义为函数 $L(x, y, \sigma)$，它是由可变尺度高斯函数 $G(x, y, \sigma)$ 与输入图像 $I(x,y)$ 卷积得到的：...</p>
  </section>
  <footer class="entry-footer"><span title='2019-05-10 00:00:00 +0000 UTC'>May 10, 2019</span>&nbsp;·&nbsp;Jifan</footer>
  <a class="entry-link" aria-label="post link to OpenCV 源码分析：SIFT 算法原理与实现" href="https://jifan.tech/posts/2019-05-10-opencv-4/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV 相机检校：原理及简单实现
    </h2>
  </header>
  <section class="entry-content">
    <p>本文主要参考自 OpenCV 官方教程 OpenCV: Camera calibration With OpenCV，大部分内容是对原文的直接翻译。
 1. 前言 利用手机相机对棋盘图拍摄得到的图像如下所示：
 图 1 手机相机拍摄图像（左）及其二值化处理后的结果（右）
  将其与原始棋盘图对比，可以明显地看出，手机拍摄图像出现了一定程度的畸变。
 图 2 原始图像（左）与二值化处理后的手机拍摄图像（右）对比
  2. 相机检校原理 目前常用的相机检校方法是附加参数法，其关键在于通过一组额外参数拟合镜头畸变，主要是径向畸变和切向畸变：
$$ \begin{align*} dx &amp; = \overbrace{x(k_1r^2&#43;k_2r^4&#43;k_3r^6)}^{\text{radial distortion}} &#43; p_1(r^2&#43;2x^2) &#43; p_2xy \cr dy &amp; = y(k_1r^2&#43;k_2r^4&#43;k_3r^6) &#43; \underbrace{p_2(r^2&#43;2y^2) &#43; p_1 xy}_{\text{tangential distortion}} \end{align*} $$
式中，
$$ x=x’-x_0, \newline y=y’-y_0, \newline r^2 = x^2 &#43; y^2 $$
其中 $(x’,y’)$ 为像片坐标的原始量测值，$k_i,(i=1,2,3)$ 为径向畸变参数，$p_j, (j=1,2)$ 为切向畸变参数。所以 5 个畸变参数构成的矩阵为：...</p>
  </section>
  <footer class="entry-footer"><span title='2019-04-18 00:00:00 +0000 UTC'>April 18, 2019</span>&nbsp;·&nbsp;Jifan</footer>
  <a class="entry-link" aria-label="post link to OpenCV 相机检校：原理及简单实现" href="https://jifan.tech/posts/2019-04-18-opencv-3/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV 点特征提取算子：Moravec，Forstner 与 Harris
    </h2>
  </header>
  <section class="entry-content">
    <p>在计算机视觉（Computer Vision）与摄影测量（Photogrammetry）中，我们在不同影像之间找到相匹配的特征，已建立两幅影像之间的联系，提取出我们所需要的信息。这些特征主要分为：
 边缘（Edges） 角点（Corners） 兴趣区域 ROI（Regions of Interest）  其中，提取点特征的算子称为兴趣算子或有利算子（Interest Operator），即运用某种算法从影像种提取我们感兴趣的、有利于某种目的的点。
人眼对角点的识别通常是在一个局部的小区域或小窗口内完成的。如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。如果这个特定的窗口在图像各个方面移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么窗口内的图像可能只是一条直线的线段。
 图 1 角点
  角点的特殊之处在于，它是两条边的交点，所以它代表这两条边的方向发生变化的点。因此，图像在该点的梯度（在各个方向上）具有明显的变化。利用这一点，前人提出了一系列算法，其中比较经典的有 Moravec 算子、Forstner 算子以及 Harris 算子等。
Moravec 算子 基本原理 Moravec 于 1977 年提出利用灰度方差提取点特征的算子，其步骤为：
1. 计算各像元的兴趣值 $IV$（Interest Value）。 在以像素 $(c, r)$ 为中心的 $w \times w$ 的窗口中（如 $5 \times 5$ 的窗口），计算四个方向相邻像素灰度差的平方和：
$$ \begin{cases} V_1 = \sum_{i = -k}^{k-1}(g_{c&#43;i,r}-g_{c&#43;i&#43;1, r})^2 \cr V_2 = \sum_{i = -k}^{k-1}(g_{c&#43;i,r&#43;i}-g_{c&#43;i&#43;1, r&#43;i&#43;1})^2 \cr V_3 = \sum_{i = -k}^{k-1}(g_{c,r&#43;i}-g_{c&#43;i&#43;1, r&#43;i&#43;1})^2 \cr V_4 = \sum_{i = -k}^{k-1}(g_{c&#43;i,r-i}-g_{c&#43;i&#43;1, r-i-1})^2 \end{cases} $$...</p>
  </section>
  <footer class="entry-footer"><span title='2019-04-02 00:00:00 +0000 UTC'>April 2, 2019</span>&nbsp;·&nbsp;Jifan</footer>
  <a class="entry-link" aria-label="post link to OpenCV 点特征提取算子：Moravec，Forstner 与 Harris" href="https://jifan.tech/posts/2019-04-02-opencv-2/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV 内置边缘检测算子：Canny，Sobel 与 Laplace
    </h2>
  </header>
  <section class="entry-content">
    <p>边缘检测（Edge Detection）是图像处理的基础内容。本文中，我从OpenCV官网上下载了最新版本的 OpenCV 4.0.1（2018-12-22），借助官方文档和网络教程完成了环境配置与测试，具体步骤不再赘述。
在 OpenCV 中可用于边缘检测的算子主要有：
 Canny 算子 Sobel 算子 Laplace 算子  Canny 算子 理论 Canny 算法是由 John F. Canny 于 1987 年在 A computational approach to edge detection 一文提出来的，它旨在满足三个主要标准：
 低错误率 (Low error rate)：意味着只检测实际存在的边缘。 高定位性 (Good localization)：将检测到的边缘像素与实际边缘像素之间的距离最小化。 最小响应 (Minimal response)：每个边缘只有一个检测器响应。  Canny 算子的步骤如下：
 滤掉任何噪声。这一过程将使用高斯滤波器。例如，一个 5×5 的高斯内核如下所示：  $$ K = \dfrac{1}{159} \begin{bmatrix} 2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \cr 4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \cr 5 &amp; 12 &amp; 15 &amp; 12 &amp; 5 \cr 4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \cr 2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \end{bmatrix} $$...</p>
  </section>
  <footer class="entry-footer"><span title='2019-03-19 00:00:00 +0000 UTC'>March 19, 2019</span>&nbsp;·&nbsp;Jifan</footer>
  <a class="entry-link" aria-label="post link to OpenCV 内置边缘检测算子：Canny，Sobel 与 Laplace" href="https://jifan.tech/posts/2019-03-19-opencv-1/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>数据结构笔记：求解斐波那契数列算法的复杂度
    </h2>
  </header>
  <section class="entry-content">
    <p>斐波那契数列 斐波那契数列（Fibonacci Sequence）是一串数字：
\[ (0,)\ 1,\ 1,\ 2,\ 3,\ 5,\ 8,\ 13,\ 21,\ 34,\ 55,\ 89,\ 144,\ … \] 很容易看出，每一个数（除第 1、2 个）都等于它之前的两个数之和。因此，用公式可归纳为： \[ F_n = \begin{cases} 0, &amp; n=0 \\ 1, &amp; n=1 \\ F_{n-1} &#43; F_{n-2}, &amp; n&gt;1 \end{cases} \]
计算复杂性理论 在将斐波那契数列用 C&#43;&#43; 代码实现并计算时间、空间复杂度之前，先要了解一下什么是所谓的“复杂度”
时间复杂度  在计算机科学中， 算法的时间复杂度（Time Complexity）是一个函数，它定性描述算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。
引自：Wikipedia，时间复杂度
 一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和即为 $T(n)$，它是该算法问题规模 $n$ 的函数，时间复杂度主要分析 $T(n)$ 的数量级。 算法的基本运算（最深层循环内的语句）的频度与 $T(n)$ 同数量级。因此通常采用算法中基本运算的频度 $f(n)$ 来分析算法的时间复杂度。因此，算法的时间复杂度记为：
\[ T(n) = O(f(n)) \]
式中，$O$ 的含义是 $T(n)$ 的数量级，其严格的数学定义是：若 $T(n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数，则存在正常数 $C$ 和 $n_0$，使得当 $n \geq n_0$ 时，都满足 $0 \leq T(n) \leq Cf(n)$。...</p>
  </section>
  <footer class="entry-footer"><span title='2019-03-01 00:00:00 +0000 UTC'>March 1, 2019</span>&nbsp;·&nbsp;Jifan</footer>
  <a class="entry-link" aria-label="post link to 数据结构笔记：求解斐波那契数列算法的复杂度" href="https://jifan.tech/posts/2019-03-01-ds-notes-1/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>C&#43;&#43; 学习笔记：数据类型、浮点数的比较以及“大数”的读取
    </h2>
  </header>
  <section class="entry-content">
    <p>再一次地、从头开始学习C/C&#43;&#43;。
 C&#43;&#43; 数据类型及其表示范围 这一部分是基础，不过我之前都没有系统性的搞清楚，所以现在还是先把这些知识点列出来，该部分参考C&#43;&#43; 数据类型 - 菜鸟教程。
1. 基本的内置类型 C&#43;&#43; 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C&#43;&#43; 数据类型：
   类型 关键字     布尔型 bool   字符型 char   整型 int   浮点型 float   双浮点型 double   无类型 void   宽字符型 wchar_t    其中，wchar_t 实际上是：
typedef wchar_t short int; 所以 wchar_t 实际上的空间和 short int 一样。 一些基本类型可以使用一个或多个类型修饰符进行修饰：
 signed unsigned short long  2....</p>
  </section>
  <footer class="entry-footer"><span title='2019-02-27 00:00:00 +0000 UTC'>February 27, 2019</span>&nbsp;·&nbsp;jifan</footer>
  <a class="entry-link" aria-label="post link to C&#43;&#43; 学习笔记：数据类型、浮点数的比较以及“大数”的读取" href="https://jifan.tech/posts/2019-02-27-cpp-study-notes-1/"></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://jifan.tech">Jifan&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>



<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>