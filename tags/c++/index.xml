<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on Jifan&#39;s Blog</title>
    <link>https://jifan.tech/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Jifan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 10 May 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://jifan.tech/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>OpenCV——SIFT 算法及源码分析（1）：原理简介</title>
      <link>https://jifan.tech/posts/2019-05-10-opencv-4/</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jifan.tech/posts/2019-05-10-opencv-4/</guid>
      <description>本文及接下来几篇同系列文章是学习 SIFT 算法和 OpenCV SIFT 源码时的学习笔记，整合自参考文献及博客。强烈建议阅读 论文原文、GitHub上的源码 以及 @赵春江 的 opencv 2.4.9 源码分析。
 Lowe 在 2004 年提出了尺度不变特征变换 (Scale Invariant Feature Transform, SIFT) 算法。 SIFT 主要由关键点探测器 (detector) 和描述符 (descriptor) 组成，它的实现分为以下四步:
 尺度空间极值探测 (scale-space extrema detection)：通过高斯差分函数搜索所有尺度和图像位置，以识别对于尺度和方向不变的潜在兴趣点。 关键点精确定位 (keypoint localization)：精确确定每个候选点的尺度与亚像素级位置，根据其稳定性阈值选择关键点。 方向分配 (orientation assignment)：基于图像的局部梯度方向，为每个特性点分配一个或多个方向角度。所有后续的操作都是相对于所确定下来的特征点的角度、尺度和位置的基础上进行的，因此特征点具有角度、尺度和位置的不变性。 关键点描述符 (keypoint descriptor)：在所选定的尺度空间内，测量特征点邻域区域的局部图像梯度，将这些梯度转换成一种允许局部较大程度的形状变形和亮度变化的描述符形式。  下面将对其进行详细阐释：
1. 尺度空间极值探测 关键点检测的第一阶段是识别可以在同一对象的不同视图下重复分配的位置和尺度。通过在素有可能的尺度进行搜索，可以检测出对图像尺度不变的稳定特征。这一过程中使用到的是被称为尺度空间 (scale space) 的尺度连续函数^[1]。
Koenderink (The structure of images, 1984) 和 Lindeberg (Detecting salient blob-like image structures and their scales with a scale-space primal sketch: A method for focus-of-attention, 1993) 已经证明，唯一可能的尺度空间核是高斯函数。因此，图像的尺度空间被定义为函数 $L(x, y, \sigma)$，它是由可变尺度高斯函数 $G(x, y, \sigma)$ 与输入图像 $I(x,y)$ 卷积得到的：</description>
    </item>
    
    <item>
      <title>OpenCV——相机检校</title>
      <link>https://jifan.tech/posts/2019-04-18-opencv-3/</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jifan.tech/posts/2019-04-18-opencv-3/</guid>
      <description>本文主要参考自 OpenCV 官方教程 OpenCV: Camera calibration With OpenCV，大部分内容是对原文的直接翻译。
 1. 前言 利用手机相机对棋盘图拍摄得到的图像如下（左边为原图，右边为二值化处理后的图像）：
如下所示，将其与原始棋盘图对比（左侧为原始图像，右侧为手机相机拍摄影像）。可以明显地看出出现了一定程度的畸变。
2. 相机检校原理 目前常用的相机检校方法是附加参数法，其关键在于通过一组额外参数拟合镜头畸变，主要是径向畸变和切向畸变：
$$ \begin{align} dx &amp;amp;= x(k_1r^2+k_2r^4+k_3r^6) + p_1(r^2+2x^2) + p_2xy \ dy &amp;amp;= \underbrace{y(k_1r^2+k_2r^4+k_3r^6)}\text{radial distortion} + \underbrace{p_2(r^2+2y^2) + p_1xy}\text{tangential distortion} \end{align} $$
式中，
$$ x=x&amp;rsquo;-x_0, \quad y=y&amp;rsquo;-y_0 \ r^2 = x^2 + y^2 $$
其中 $(x&amp;rsquo;,y&amp;rsquo;)$ 为像片坐标的原始量测值，$k_i,(i=1,2,3)$ 为径向畸变参数，$p_j, (j=1,2)$ 为切向畸变参数。所以 5 个畸变参数构成的矩阵为：
$$ distortion_coeffients = (\begin{matrix}k_1&amp;amp;k_2&amp;amp;p_1&amp;amp;p_2&amp;amp;k_3\end{matrix}) $$
对于影像坐标和物空间坐标的转换关系为：
$$ \begin{bmatrix}x\y\f\end{bmatrix}= K \begin{bmatrix}X\Y\Z\end{bmatrix}= \begin{bmatrix}f_x&amp;amp;0&amp;amp;c_x\0&amp;amp;f_y&amp;amp;c_y\0&amp;amp;0&amp;amp;1\end{bmatrix} \begin{bmatrix}X\Y\Z\end{bmatrix} $$</description>
    </item>
    
    <item>
      <title>OpenCV——点特征提取算子：Moravec，Forstner 与 Harris</title>
      <link>https://jifan.tech/posts/2019-04-02-opencv-2/</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jifan.tech/posts/2019-04-02-opencv-2/</guid>
      <description>在计算机视觉（Computer Vision）与摄影测量（Photogrammetry）中，我们在不同影像之间找到相匹配的特征，已建立两幅影像之间的联系，提取出我们所需要的信息。这些特征主要分为：
 边缘（Edges） 角点（Corners） 兴趣区域 ROI（Regions of Interest）  其中，提取点特征的算子称为兴趣算子或有利算子（Interest Operator），即运用某种算法从影像种提取我们感兴趣的、有利于某种目的的点。
人眼对角点的识别通常是在一个局部的小区域或小窗口内完成的。如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。如果这个特定的窗口在图像各个方面移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么窗口内的图像可能只是一条直线的线段。
角点的特殊之处在于，它是两条边的交点，所以它代表这两条边的方向发生变化的点。因此，图像在该点的梯度（在各个方向上）具有明显的变化。利用这一点，前人提出了一系列算法，其中比较经典的有 Moravec 算子、Forstner 算子以及 Harris 算子等。
Moravec 算子 基本原理 Moravec 于 1977 年提出利用灰度方差提取点特征的算子，其步骤为：
1. 计算各像元的兴趣值 $IV$（Interest Value）。 在以像素 $(c, r)$ 为中心的 $w \times w$ 的窗口中（如 $5 \times 5$ 的窗口），计算四个方向相邻像素灰度差的平方和：
$$ \begin{cases} V_1 &amp;amp;=&amp;amp; \sum_{i = -k}^{k-1}(g_{c+i,r}-g_{c+i+1, r})^2 \[2ex] V_2 &amp;amp;=&amp;amp; \sum_{i = -k}^{k-1}(g_{c+i,r+i}-g_{c+i+1, r+i+1})^2 \[2ex] V_3 &amp;amp;=&amp;amp; \sum_{i = -k}^{k-1}(g_{c,r+i}-g_{c+i+1, r+i+1})^2 \[2ex] V_4 &amp;amp;=&amp;amp; \sum_{i = -k}^{k-1}(g_{c+i,r-i}-g_{c+i+1, r-i-1})^2 \end{cases} $$</description>
    </item>
    
    <item>
      <title>OpenCV——内置边缘检测算子：Canny，Sobel 与 Laplace</title>
      <link>https://jifan.tech/posts/2019-03-19-opencv-1/</link>
      <pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jifan.tech/posts/2019-03-19-opencv-1/</guid>
      <description>边缘检测（Edge Detection）是图像处理的基础内容。本文中，我从OpenCV官网上下载了最新版本的 OpenCV 4.0.1（2018-12-22），借助官方文档和网络教程完成了环境配置与测试，具体步骤不再赘述。
在 OpenCV 中可用于边缘检测的算子主要有：
 Canny 算子 Sobel 算子 Laplace 算子   Canny 算子 理论 Canny 算法是由 John F. Canny 于 1987 年在 A computational approach to edge detection 一文提出来的，它旨在满足三个主要标准：
 **低错误率（Low error rate）：**意味着只检测实际存在的边缘。 **高定位性（Good localization）：**将检测到的边缘像素与实际边缘像素之间的距离最小化。 **最小响应（Minimal response）：**每个边缘只有一个检测器响应。  Canny 算子的步骤如下：
 滤掉任何噪声。这一过程将使用高斯滤波器。例如，一个 5×5 的高斯内核如下所示：  $$ K = \dfrac{1}{159}\begin{bmatrix} 2 &amp;amp; 4 &amp;amp; 5 &amp;amp; 4 &amp;amp; 2 \ 4 &amp;amp; 9 &amp;amp; 12 &amp;amp; 9 &amp;amp; 4 \ 5 &amp;amp; 12 &amp;amp; 15 &amp;amp; 12 &amp;amp; 5 \ 4 &amp;amp; 9 &amp;amp; 12 &amp;amp; 9 &amp;amp; 4 \ 2 &amp;amp; 4 &amp;amp; 5 &amp;amp; 4 &amp;amp; 2 \end{bmatrix} $$</description>
    </item>
    
    <item>
      <title>PAT Advanced Level Practice (I)</title>
      <link>https://jifan.tech/posts/2019-03-16-pat-a-1/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jifan.tech/posts/2019-03-16-pat-a-1/</guid>
      <description>PAT Advanced Level 刷题（一）
PTA | 程序设计类实验辅助教学平台
 PAT A 1025 解题思路
题目大意为：有 N（≤100） 个考场，每个考场有若干数量（K≤300）的考生。现给出各个考场中考生的准考证号与分数，要求将所有考生按分数从高到低排序，并按顺序输出所有考生的准考证号、排名、考场号及考场内排名。
题目要求的信息（准考证号、分数等）可以用结构体 Student 来存放。对考生进行排序可以使用 C++ 标准库中的 sort() 函数，题目中指出结果应按照考生排名递增排序，相同分数的考生排名相同且按照准考证号递增排序。因此，我们需要准们编写一个符合题目条件的 cmp 函数，它应该满足如下规则：
 当分数不同时，按分数从大到小排序 否则，按准考证号从小到大排序。  也即：
bool cmp(Student a, Student b) { if (a.score != b.score) return a.score &amp;gt; b.score; // 先按分数从高到低排序  else return strcmp(a.id, b.id) &amp;lt; 0;	// 若分数相同，则按准考证号从小到大排序 } 算法本身分为三步：
 按考场读入各考生的信息，并对当前读入考场的所有考生进行排序。之后将该考场的所有考生的排名写入其结构体中。 对所有考生进行排序 按照排序，一遍计算总排名，一遍输出信息  参考代码
#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; struct Student { char id[15];	// 准考证号  int score;	// 分数  int location_number;	// 考场号  int local_rank;	// 考场内排名 }stu[30010]; bool cmp(Student a, Student b) { if (a.</description>
    </item>
    
    <item>
      <title>数据结构——求解斐波那契数列算法的复杂度</title>
      <link>https://jifan.tech/posts/2019-03-01-ds-1/</link>
      <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jifan.tech/posts/2019-03-01-ds-1/</guid>
      <description>斐波那契数列 斐波那契数列（Fibonacci Sequence）是一串数字：
\[ (0,) 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, &amp;hellip; \] 很容易看出，每一个数（除第 1、2 个）都等于它之前的两个数之和。因此，用公式可归纳为： \[ F_n = \begin{cases} 0, &amp;amp; n=0 \\ 1, &amp;amp; n=1 \\ F_{n-1} + F_{n-2}, &amp;amp; n&amp;gt;1 \end{cases} \]
计算复杂性理论 在将斐波那契数列用 C++ 代码实现并计算时间、空间复杂度之前，先要了解一下什么是所谓的“复杂度”
时间复杂度  在计算机科学中， 算法的时间复杂度（Time Complexity）是一个函数，它定性描述算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。
 一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和即为 $T(n)$，它是该算法问题规模 $n$ 的函数，时间复杂度主要分析 $T(n)$ 的数量级。 算法的基本运算（最深层循环内的语句）的频度与 $T(n)$ 同数量级。因此通常采用算法中基本运算的频度 $f(n)$ 来分析算法的时间复杂度。因此，算法的时间复杂度记为： \[ T(n) = O(f(n)) \] 式中，$O$ 的含义是 $T(n)$ 的数量级，其严格的数学定义是：若 $T(n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数，则存在正常数 $C$ 和 $n_0$，使得当 $n \geq n_0$ 时，都满足 $0 \leq T(n) \leq Cf(n)$。</description>
    </item>
    
    <item>
      <title>PAT Basic Level Practice (I)</title>
      <link>https://jifan.tech/posts/2019-02-28-pat-basic-level-practice-1/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jifan.tech/posts/2019-02-28-pat-basic-level-practice-1/</guid>
      <description>PAT Basic Level 刷题（一）
PTA | 程序设计类实验辅助教学平台
 PAT B 1001 解题思路
题目比较基础，利用循环语句和条件语句实现对目标整数的不断缩小，直至 n == 1，通过变量 step 来计算步数（砍了多少次）
参考代码
#include &amp;lt;stdio.h&amp;gt;int main(){ int n, step = 0; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); // 输入题目给出的 n  while (n != 1) { if (n % 2 == 0) n /= 2; else n = (3 * n + 1) / 2; step++; } printf(&amp;#34;%d\n&amp;#34;, step); return 0; } PAT B 1002 解题思路
 题目要求读入一个小于 10e100 的整数 （如，1234567890987654321123456789），它已经超出了 int (-2^31 ~ 2^31 - 1) 或者 long int (-2^63 ~ 2^63 - 1) 的范围，因此需要将其当做字符串读入。 将读入字符串的每一位“相加”即可得到 n 的各位数字之和 sum 用 / 和 % 方法获取 sum 的每一位  参考代码</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 学习笔记（一）：初学者的小窍门</title>
      <link>https://jifan.tech/posts/2019-02-27-cpp-study-notes-1/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jifan.tech/posts/2019-02-27-cpp-study-notes-1/</guid>
      <description>一个多月以来，确定好了考研的计划。现在开始准备刷题学习一些算法的基础，也是从头开始学习C/C++，当然在学习过程中踩了不少坑，在这里进行一些总结。
 C++ 数据类型及其表示范围 这一部分是基础，不过我之前都没有系统性的搞清楚，所以现在还是先把这些知识点列出来，该部分参考C++ 数据类型 - 菜鸟教程。
1. 基本的内置类型 C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：
   类型 关键字     布尔型 bool   字符型 char   整型 int   浮点型 float   双浮点型 double   无类型 void   宽字符型 wchar_t    其中，wchar_t 实际上是：
typedef wchar_t short int; 所以 wchar_t 实际上的空间是和 short int 一样。 一些基本类型可以使用一个或多个类型修饰符进行修饰：
 signed unsigned short long  2.</description>
    </item>
    
  </channel>
</rss>
