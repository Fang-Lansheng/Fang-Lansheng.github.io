<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Data Structure on Jifan&#39;s Blog</title>
    <link>https://jifan.tech/tags/data-structure/</link>
    <description>Recent content in Data Structure on Jifan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Mar 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://jifan.tech/tags/data-structure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据结构笔记：求解斐波那契数列算法的复杂度</title>
      <link>https://jifan.tech/posts/2019-03-01/ds-notes-1/</link>
      <pubDate>Fri, 01 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jifan.tech/posts/2019-03-01/ds-notes-1/</guid>
      <description>斐波那契数列 斐波那契数列（Fibonacci Sequence）是一串数字：
\[ (0,)\ 1,\ 1,\ 2,\ 3,\ 5,\ 8,\ 13,\ 21,\ 34,\ 55,\ 89,\ 144,\ &amp;hellip; \] 很容易看出，每一个数（除第 1、2 个）都等于它之前的两个数之和。因此，用公式可归纳为： \[ F_n = \begin{cases} 0, &amp;amp; n=0 \\ 1, &amp;amp; n=1 \\ F_{n-1} + F_{n-2}, &amp;amp; n&amp;gt;1 \end{cases} \]
计算复杂性理论 在将斐波那契数列用 C++ 代码实现并计算时间、空间复杂度之前，先要了解一下什么是所谓的“复杂度”
时间复杂度  在计算机科学中， 算法的时间复杂度（Time Complexity）是一个函数，它定性描述算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。
引自：Wikipedia，时间复杂度
 一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和即为 $T(n)$，它是该算法问题规模 $n$ 的函数，时间复杂度主要分析 $T(n)$ 的数量级。 算法的基本运算（最深层循环内的语句）的频度与 $T(n)$ 同数量级。因此通常采用算法中基本运算的频度 $f(n)$ 来分析算法的时间复杂度。因此，算法的时间复杂度记为：
\[ T(n) = O(f(n)) \]
式中，$O$ 的含义是 $T(n)$ 的数量级，其严格的数学定义是：若 $T(n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数，则存在正常数 $C$ 和 $n_0$，使得当 $n \geq n_0$ 时，都满足 $0 \leq T(n) \leq Cf(n)$。</description>
    </item>
    
  </channel>
</rss>
