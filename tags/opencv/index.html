<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>OpenCV | Jifan&#39;s Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="Jifan&#39;s Blog - https://jifan.tech">
<meta name="author" content="Jifan">
<link rel="canonical" href="https://jifan.tech/tags/opencv/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jifan.tech/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jifan.tech/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jifan.tech/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jifan.tech/apple-touch-icon.png">
<link rel="mask-icon" href="https://jifan.tech/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://jifan.tech/tags/opencv/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="OpenCV" />
<meta property="og:description" content="Jifan&#39;s Blog - https://jifan.tech" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://jifan.tech/tags/opencv/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="OpenCV"/>
<meta name="twitter:description" content="Jifan&#39;s Blog - https://jifan.tech"/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jifan.tech" accesskey="h" title="Jifan&#39;s Blog (Alt + H)">Jifan&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jifan.tech/archives/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>OpenCV</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV——SIFT 算法及源码分析（1）：原理简介
    </h2>
  </header>
  <section class="entry-content">
    <p>本文及接下来几篇同系列文章是学习 SIFT 算法和 OpenCV SIFT 源码时的学习笔记，整合自参考文献及博客。强烈建议阅读 论文原文、GitHub上的源码 以及 @赵春江 的 opencv 2.4.9 源码分析。
 Lowe 在 2004 年提出了尺度不变特征变换 (Scale Invariant Feature Transform, SIFT) 算法。 SIFT 主要由关键点探测器 (detector) 和描述符 (descriptor) 组成，它的实现分为以下四步:
 尺度空间极值探测 (scale-space extrema detection)：通过高斯差分函数搜索所有尺度和图像位置，以识别对于尺度和方向不变的潜在兴趣点。 关键点精确定位 (keypoint localization)：精确确定每个候选点的尺度与亚像素级位置，根据其稳定性阈值选择关键点。 方向分配 (orientation assignment)：基于图像的局部梯度方向，为每个特性点分配一个或多个方向角度。所有后续的操作都是相对于所确定下来的特征点的角度、尺度和位置的基础上进行的，因此特征点具有角度、尺度和位置的不变性。 关键点描述符 (keypoint descriptor)：在所选定的尺度空间内，测量特征点邻域区域的局部图像梯度，将这些梯度转换成一种允许局部较大程度的形状变形和亮度变化的描述符形式。  下面将对其进行详细阐释：
1. 尺度空间极值探测 关键点检测的第一阶段是识别可以在同一对象的不同视图下重复分配的位置和尺度。通过在素有可能的尺度进行搜索，可以检测出对图像尺度不变的稳定特征。这一过程中使用到的是被称为尺度空间 (scale space) 的尺度连续函数^[1]。
Koenderink (The structure of images, 1984) 和 Lindeberg (Detecting salient blob-like image structures and their scales with a scale-space primal sketch: A method for focus-of-attention, 1993) 已经证明，唯一可能的尺度空间核是高斯函数。因此，图像的尺度空间被定义为函数 $L(x, y, \sigma)$，它是由可变尺度高斯函数 $G(x, y, \sigma)$ 与输入图像 $I(x,y)$ 卷积得到的：...</p>
  </section>
  <footer class="entry-footer"><span title='2019-05-10 00:00:00 +0000 UTC'>May 10, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to OpenCV——SIFT 算法及源码分析（1）：原理简介" href="https://jifan.tech/posts/2019-05-10-opencv-4/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV——相机检校
    </h2>
  </header>
  <section class="entry-content">
    <p>本文主要参考自 OpenCV 官方教程 OpenCV: Camera calibration With OpenCV，大部分内容是对原文的直接翻译。
 1. 前言 利用手机相机对棋盘图拍摄得到的图像如下（左边为原图，右边为二值化处理后的图像）：
如下所示，将其与原始棋盘图对比（左侧为原始图像，右侧为手机相机拍摄影像）。可以明显地看出出现了一定程度的畸变。
2. 相机检校原理 目前常用的相机检校方法是附加参数法，其关键在于通过一组额外参数拟合镜头畸变，主要是径向畸变和切向畸变：
$$ \begin{align} dx &amp;= x(k_1r^2&#43;k_2r^4&#43;k_3r^6) &#43; p_1(r^2&#43;2x^2) &#43; p_2xy \ dy &amp;= \underbrace{y(k_1r^2&#43;k_2r^4&#43;k_3r^6)}\text{radial distortion} &#43; \underbrace{p_2(r^2&#43;2y^2) &#43; p_1xy}\text{tangential distortion} \end{align} $$
式中，
$$ x=x’-x_0, \quad y=y’-y_0 \ r^2 = x^2 &#43; y^2 $$
其中 $(x’,y’)$ 为像片坐标的原始量测值，$k_i,(i=1,2,3)$ 为径向畸变参数，$p_j, (j=1,2)$ 为切向畸变参数。所以 5 个畸变参数构成的矩阵为：
$$ distortion_coeffients = (\begin{matrix}k_1&amp;k_2&amp;p_1&amp;p_2&amp;k_3\end{matrix}) $$
对于影像坐标和物空间坐标的转换关系为：
$$ \begin{bmatrix}x\y\f\end{bmatrix}= K \begin{bmatrix}X\Y\Z\end{bmatrix}= \begin{bmatrix}f_x&amp;0&amp;c_x\0&amp;f_y&amp;c_y\0&amp;0&amp;1\end{bmatrix} \begin{bmatrix}X\Y\Z\end{bmatrix} $$...</p>
  </section>
  <footer class="entry-footer"><span title='2019-04-18 00:00:00 +0000 UTC'>April 18, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to OpenCV——相机检校" href="https://jifan.tech/posts/2019-04-18-opencv-3/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV——点特征提取算子：Moravec，Forstner 与 Harris
    </h2>
  </header>
  <section class="entry-content">
    <p>在计算机视觉（Computer Vision）与摄影测量（Photogrammetry）中，我们在不同影像之间找到相匹配的特征，已建立两幅影像之间的联系，提取出我们所需要的信息。这些特征主要分为：
 边缘（Edges） 角点（Corners） 兴趣区域 ROI（Regions of Interest）  其中，提取点特征的算子称为兴趣算子或有利算子（Interest Operator），即运用某种算法从影像种提取我们感兴趣的、有利于某种目的的点。
人眼对角点的识别通常是在一个局部的小区域或小窗口内完成的。如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。如果这个特定的窗口在图像各个方面移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么窗口内的图像可能只是一条直线的线段。
角点的特殊之处在于，它是两条边的交点，所以它代表这两条边的方向发生变化的点。因此，图像在该点的梯度（在各个方向上）具有明显的变化。利用这一点，前人提出了一系列算法，其中比较经典的有 Moravec 算子、Forstner 算子以及 Harris 算子等。
Moravec 算子 基本原理 Moravec 于 1977 年提出利用灰度方差提取点特征的算子，其步骤为：
1. 计算各像元的兴趣值 $IV$（Interest Value）。 在以像素 $(c, r)$ 为中心的 $w \times w$ 的窗口中（如 $5 \times 5$ 的窗口），计算四个方向相邻像素灰度差的平方和：
$$ \begin{cases} V_1 &amp;=&amp; \sum_{i = -k}^{k-1}(g_{c&#43;i,r}-g_{c&#43;i&#43;1, r})^2 \[2ex] V_2 &amp;=&amp; \sum_{i = -k}^{k-1}(g_{c&#43;i,r&#43;i}-g_{c&#43;i&#43;1, r&#43;i&#43;1})^2 \[2ex] V_3 &amp;=&amp; \sum_{i = -k}^{k-1}(g_{c,r&#43;i}-g_{c&#43;i&#43;1, r&#43;i&#43;1})^2 \[2ex] V_4 &amp;=&amp; \sum_{i = -k}^{k-1}(g_{c&#43;i,r-i}-g_{c&#43;i&#43;1, r-i-1})^2 \end{cases} $$...</p>
  </section>
  <footer class="entry-footer"><span title='2019-04-02 00:00:00 +0000 UTC'>April 2, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to OpenCV——点特征提取算子：Moravec，Forstner 与 Harris" href="https://jifan.tech/posts/2019-04-02-opencv-2/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV——内置边缘检测算子：Canny，Sobel 与 Laplace
    </h2>
  </header>
  <section class="entry-content">
    <p>边缘检测（Edge Detection）是图像处理的基础内容。本文中，我从OpenCV官网上下载了最新版本的 OpenCV 4.0.1（2018-12-22），借助官方文档和网络教程完成了环境配置与测试，具体步骤不再赘述。
在 OpenCV 中可用于边缘检测的算子主要有：
 Canny 算子 Sobel 算子 Laplace 算子   Canny 算子 理论 Canny 算法是由 John F. Canny 于 1987 年在 A computational approach to edge detection 一文提出来的，它旨在满足三个主要标准：
 **低错误率（Low error rate）：**意味着只检测实际存在的边缘。 **高定位性（Good localization）：**将检测到的边缘像素与实际边缘像素之间的距离最小化。 **最小响应（Minimal response）：**每个边缘只有一个检测器响应。  Canny 算子的步骤如下：
 滤掉任何噪声。这一过程将使用高斯滤波器。例如，一个 5×5 的高斯内核如下所示：  $$ K = \dfrac{1}{159}\begin{bmatrix} 2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \ 4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \ 5 &amp; 12 &amp; 15 &amp; 12 &amp; 5 \ 4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \ 2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \end{bmatrix} $$...</p>
  </section>
  <footer class="entry-footer"><span title='2019-03-19 00:00:00 +0000 UTC'>March 19, 2019</span>&nbsp;·&nbsp;Thistledown</footer>
  <a class="entry-link" aria-label="post link to OpenCV——内置边缘检测算子：Canny，Sobel 与 Laplace" href="https://jifan.tech/posts/2019-03-19-opencv-1/"></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://jifan.tech">Jifan&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
