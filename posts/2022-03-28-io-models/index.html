<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>I/O multiplexing: select, poll and epoll | Jifan&#39;s Blog</title>
<meta name="keywords" content="Linux, I/O" />
<meta name="description" content="TL,DR.
 The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.   1. Why not blocking I/O? Under the convensional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred.">
<meta name="author" content="Jifan">
<link rel="canonical" href="https://jifan.tech/posts/2022-03-28-io-models/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d2d913f96f20672531467f8a00a1afae6af2b44b8ba24b7a5cab31330f0bcb2c.css" integrity="sha256-0tkT&#43;W8gZyUxRn&#43;KAKGvrmrytEuLokt6XKsxMw8Lyyw=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://jifan.tech/imgs/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jifan.tech/imgs/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jifan.tech/imgs/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jifan.tech/imgs/apple-touch-icon.png">
<link rel="mask-icon" href="https://jifan.tech/imgs/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="I/O multiplexing: select, poll and epoll" />
<meta property="og:description" content="TL,DR.
 The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.   1. Why not blocking I/O? Under the convensional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jifan.tech/posts/2022-03-28-io-models/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-28T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-03-28T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="I/O multiplexing: select, poll and epoll"/>
<meta name="twitter:description" content="TL,DR.
 The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.   1. Why not blocking I/O? Under the convensional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://jifan.tech/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "I/O multiplexing: select, poll and epoll",
      "item": "https://jifan.tech/posts/2022-03-28-io-models/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "I/O multiplexing: select, poll and epoll",
  "name": "I\/O multiplexing: select, poll and epoll",
  "description": "TL,DR.\n The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.   1. Why not blocking I/O? Under the convensional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred.",
  "keywords": [
    "Linux", "I/O"
  ],
  "articleBody": " TL,DR.\n The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.   1. Why not blocking I/O? Under the convensional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred. For example, when reading from the pipe,\n a read() call normally blocks if no data is currently persent in the pipe. And, a write() call blocks if there is insufficient space in the pipe to hold the data to be written.  It’s no doubt that the traditional blocking I/O model is already stretched when we need to monitor multiple file descriptors, or avoid blocking the current process if I/O is not possible on a file descriptor.\nThere are two direct approaches to partially address these needs:\n Nonblocking I/O. Use of multiple processes or threads.  Nonblocking I/O allows us to periodically check (“poll”) whether I/O is possible. For expample, we can make an input file descriptor nonblocking, and then periodically performing nonblocking reads. If we need to monitor multiple file descriptor, then we mark them all nonblocking, and poll each of them in turn. However, polling in this manner is usually undesirable. If polling is done only infrequently, then the latency before an application responds to an I/O event may be unacceptably long; on the other hand, polling in a tight loop wastes CPU time.\nIf we need to handle I/O on multiple file descriptors, we can create one child process or thread for each descriptor. To do so, however, an inter-process/thread communication mechanism is needed to inform the parent about the status of the I/O operations, which demanding more resources and can lead to programming difficulties.\nFortunately, modern Linux provides the following alternative I/O models.\nI/O multiplexing: select() \u0026 poll() I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() system calls perform I/O multiplexing.\nSignal-driven I/O Signal-driven I/O is a technique whereby a process requests that the kernel send it a signal when input is avaiable or data can be written on a specified file descriptor. The process can then carry on performing other activities, and is notified when I/O becomes possible via receipt of the signal. When monitoring large numbers of file descriptors, signal-driven I/O provides significantly better performance than select() and poll().\nThe Linux-specific epoll API The epoll API is a Linux-specifc feature that first appeared in Linux 2.6 (?). Like the I/O multiplexing APIs, the epoll API allows a process to monitor multiple file descriptors to see if I/O is possible on any of them. Like signal-driven I/O, the epoll API provides much better performance when monitoring large numbers of file descriptors.\n",
  "wordCount" : "483",
  "inLanguage": "en",
  "datePublished": "2022-03-28T00:00:00Z",
  "dateModified": "2022-03-28T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Jifan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jifan.tech/posts/2022-03-28-io-models/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jifan's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jifan.tech/imgs/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jifan.tech" accesskey="h" title="Jifan&#39;s Blog (Alt + H)">Jifan&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jifan.tech/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">












<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jifan.tech">Home</a>&nbsp;»&nbsp;<a href="https://jifan.tech/posts/">Posts</a></div>
    <h1 class="post-title">
      I/O multiplexing: select, poll and epoll<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h1>
    <div class="post-meta"><span title='2022-03-28 00:00:00 +0000 UTC'>March 28, 2022</span>&nbsp;·&nbsp;Jifan

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-why-not-blocking-io" aria-label="1. Why not blocking I/O?">1. Why not blocking I/O?</a></li>
                <li>
                    <a href="#io-multiplexing-select--poll" aria-label="I/O multiplexing: select() &amp;amp; poll()">I/O multiplexing: <code>select()</code> &amp; <code>poll()</code></a></li>
                <li>
                    <a href="#signal-driven-io" aria-label="Signal-driven I/O">Signal-driven I/O</a></li>
                <li>
                    <a href="#the-linux-specific-epoll-api" aria-label="The Linux-specific epoll API">The Linux-specific <em>epoll</em> API</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p><strong>TL,DR.</strong></p>
<ul>
<li>The <code>select()</code> and <code>poll()</code> are system calls to monitor file descriptors.</li>
<li>And the <em>epoll</em> is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.</li>
</ul>
</blockquote>
<h1 id="1-why-not-blocking-io">1. Why not blocking I/O?<a hidden class="anchor" aria-hidden="true" href="#1-why-not-blocking-io">#</a></h1>
<p>Under the convensional file I/O model, a process performs I/O on just one file descriptor, named <em><strong>fd</strong></em>, at a time, and each I/O system call blocks until the data is transferred. For example, when reading from the pipe,</p>
<ul>
<li>a <code>read()</code> call normally blocks if no data is currently persent in the pipe. And,</li>
<li>a <code>write()</code> call blocks if there is insufficient space in the pipe to hold the data to be written.</li>
</ul>
<p>It&rsquo;s no doubt that the traditional blocking I/O model is already stretched when we need to monitor multiple file descriptors, or avoid blocking the current process if I/O is not possible on a file descriptor.</p>
<p>There are two direct approaches to partially address these needs:</p>
<ul>
<li>Nonblocking I/O.</li>
<li>Use of multiple processes or threads.</li>
</ul>
<p>Nonblocking I/O allows us to periodically check (&ldquo;poll&rdquo;) whether I/O is possible.
For expample, we can make an input file descriptor nonblocking, and then periodically performing nonblocking reads. If we need to monitor multiple file descriptor, then we mark them all nonblocking, and poll each of them in turn.
However, polling in this manner is usually undesirable. If polling is done only infrequently, then the latency before an application responds to an I/O event may be unacceptably long; on the other hand, polling in a tight loop wastes CPU time.</p>
<!-- raw HTML omitted -->
<p>If we need to handle I/O on multiple file descriptors, we can create one child process or thread for each descriptor. To do so, however, an inter-process/thread communication mechanism is needed to inform the parent about the status of the I/O operations, which demanding more resources and can lead to programming difficulties.</p>
<p>Fortunately, modern Linux provides the following alternative I/O models.</p>
<h1 id="io-multiplexing-select--poll">I/O multiplexing: <code>select()</code> &amp; <code>poll()</code><a hidden class="anchor" aria-hidden="true" href="#io-multiplexing-select--poll">#</a></h1>
<p><strong>I/O multiplexing</strong> allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The <code>select()</code> and <code>poll()</code> system calls perform I/O multiplexing.</p>
<h1 id="signal-driven-io">Signal-driven I/O<a hidden class="anchor" aria-hidden="true" href="#signal-driven-io">#</a></h1>
<p><strong>Signal-driven I/O</strong> is a technique whereby a process requests that the kernel send it a signal when input is avaiable or data can be written on a specified file descriptor. The process can then carry on performing other activities, and is notified when I/O becomes possible via receipt of the signal. When monitoring large numbers of file descriptors, signal-driven I/O provides significantly better performance than <code>select()</code> and <code>poll()</code>.</p>
<h1 id="the-linux-specific-epoll-api">The Linux-specific <em>epoll</em> API<a hidden class="anchor" aria-hidden="true" href="#the-linux-specific-epoll-api">#</a></h1>
<p><strong>The <em>epoll</em> API</strong> is a Linux-specifc feature that first appeared in Linux 2.6 (?). Like the I/O multiplexing APIs, the <em>epoll</em> API allows a process to monitor multiple file descriptors to see if I/O is possible on any of them. Like signal-driven I/O, the <em>epoll</em> API provides much better performance when monitoring large numbers of file descriptors.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://jifan.tech">Jifan&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js" integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            
            throwOnError : false
        });
    });
</script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>