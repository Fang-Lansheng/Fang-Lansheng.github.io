<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>I/O multiplexing: select, poll and epoll | Jifan&#39;s Blog</title>
<meta name="keywords" content="Linux, I/O" />
<meta name="description" content="TL,DR.
 I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors. For now, this article is merely a copy/summary of the introduction of them in man pages.">
<meta name="author" content="Jifan">
<link rel="canonical" href="https://jifan.tech/posts/2022-03-28-io-models/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d2d913f96f20672531467f8a00a1afae6af2b44b8ba24b7a5cab31330f0bcb2c.css" integrity="sha256-0tkT&#43;W8gZyUxRn&#43;KAKGvrmrytEuLokt6XKsxMw8Lyyw=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://jifan.tech/imgs/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jifan.tech/imgs/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jifan.tech/imgs/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jifan.tech/imgs/apple-touch-icon.png">
<link rel="mask-icon" href="https://jifan.tech/imgs/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="I/O multiplexing: select, poll and epoll" />
<meta property="og:description" content="TL,DR.
 I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors. For now, this article is merely a copy/summary of the introduction of them in man pages." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jifan.tech/posts/2022-03-28-io-models/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-28T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-03-28T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="I/O multiplexing: select, poll and epoll"/>
<meta name="twitter:description" content="TL,DR.
 I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors. For now, this article is merely a copy/summary of the introduction of them in man pages."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://jifan.tech/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "I/O multiplexing: select, poll and epoll",
      "item": "https://jifan.tech/posts/2022-03-28-io-models/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "I/O multiplexing: select, poll and epoll",
  "name": "I\/O multiplexing: select, poll and epoll",
  "description": "TL,DR.\n I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors. For now, this article is merely a copy/summary of the introduction of them in man pages.",
  "keywords": [
    "Linux", "I/O"
  ],
  "articleBody": " TL,DR.\n I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors. For now, this article is merely a copy/summary of the introduction of them in man pages. Many parts of the article still need to be revised and supplemented.   Why not blocking I/O? Under the conventional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred. For example, when reading from the pipe,\n a read() call normally blocks if no data is currently present in the pipe. And, a write() call blocks if there is insufficient space in the pipe to hold the data to be written.  It’s no doubt that the traditional blocking I/O model is already stretched when we need to monitor multiple file descriptors, or avoid blocking the current process if I/O is not possible on a file descriptor.\nThere are two direct approaches to partially address these needs:\n Non-blocking I/O. Use of multiple processes or threads.  Non-blocking I/O allows us to periodically check (“poll”) whether I/O is possible. For example, we can make an input file descriptor non-blocking, and then periodically performing non-blocking reads. If we need to monitor multiple file descriptor, then we mark them all non-blocking, and poll each of them in turn. However, polling in this manner is usually undesirable. If polling is done only infrequently, then the latency before an application responds to an I/O event may be unacceptably long; on the other hand, polling in a tight loop wastes CPU time.\nIf we need to handle I/O on multiple file descriptors, we can create one child process or thread for each descriptor. To do so, however, an inter-process/thread communication mechanism is needed to inform the parent about the status of the I/O operations, which demanding more resources and can lead to programming difficulties.\nFortunately, modern Linux provides the following alternative I/O models.\nWhy not non-blocking I/O? If we place a file descriptor in non-blocking mode by enabling the O_NONBLOCK open file status flag, then an I/O system call that can’t be immediately completed returns an error instead of blocking. Non-blocking I/O can be employed with pipes, FIFOs, sockets, terminals, pseudoterminals, and some other types of devices.\nNon-blocking I/O allows us to periodically check (“poll”) whether I/O is possible on a file descriptor. If we need to monitor multiple file descriptors, then we mark them all non-blocking, and poll each of them in turn.\nHowever, polling in this manner is usually undesirable. If polling is done only infrequently, then the latency before an application responds to an I/O event may be unacceptably long; on the other hand, polling in a tight loop wastes CPU time.\nI/O multiplexing: select() \u0026 poll() I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() system calls perform I/O multiplexing.\nThe select() system call #include  #include  int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); void FD_CLR(int fd, fd_set *set); int FD_ISSET(int fd, fd_set *set); void FD_SET(int fd, fd_set *set); void FD_ZERO(fd_set *set);  readfds, writefds, and exceptfds: pointers to file descriptor sets, represented using the data type fd_set.  readfds: the set of file descriptors to be tested to see if input is possible; writefds: the set of file descriptors to be tested to see if output is possible; exceptfds: the set of file descriptors to be tested to see if an exceptional condition has occurred. If we are not interested in a particular class of events, then the corresponding fd_set argument can be specified as NULL.   Typically, the fd_set data type is implemented as a bit mask (an array).  Ignoring the details, we just need to manipulate an fd_set with the following macros/functions:  FD_ZERO(): initializes the set pointed to by fdset to be empty. FD_SET(): adds the file descriptor fd to the set pointed to by fdset. FD_CLR(): removes the file descriptor fd from the set pointed to by fdset. FD_ISSET(): returns true if the file descriptor fd is a member of the set pointed to by fdset.   A file descriptor set has a maximum size, defined by the constant FD_SETSIZE. On Linux, this constant has the value 1024   The nfds argument must be set one greater than the highest file descriptor number included in any of the three file descriptor sets. The timeout argument controls the blocking behavior of select()  When specified as NULL: select() blocks indefinitely (until the event it is waiting for is ready). Otherwise, timeout specifies an upper limit on the time for which select() is to wait.   Return value  A return value of –1 indicates that an error occurred. A return value of 0 means that the call timed out before any file descriptor became ready. In this case, each of the returned file descriptor sets will be empty. A positive return value indicates that one or more file descriptors is ready. The return value is the number of ready descriptors.   The select() call modifies each of these structures so that, on return, they contain the set of file descriptors that are ready. (Since these structures are modified by the call, we must ensure that we reinitialize them if we are repeatedly calling select() from within a loop.) The structures can then be examined using FD_ISSET(). Each time select() is called, these fd_sets are copied into the kernel, modified and returned. We need to check each bit mask (using FD_ISSET()) to determine which I/O events are ready.  To read more: https://man7.org/linux/man-pages/man2/select.2.html\nThe poll() system call The poll() system call performs a similar task to select().\n#include  int poll(struct pollfd fds[], nfds_t nfds, int timeout);  fds: lists the file descriptors to be monitored by poll().  An array of pollfd structures, defined as follows: struct pollfd { int fd; /* File descriptor */ short events; /* Requested events bit mask */ short revents; /* Returned events bit mask */ };  The events and revents fields of the pollfd structure are bit masks.   nfds: the number of items in the fds array. timeout: determines the blocking behavior of poll():  If timeout equals –1, block until one of the file descriptors listed in the fds array is ready (as defined by the corresponding events field) or a signal is caught. If timeout equals 0, do not block (just perform a check to see which file descriptors are ready). If timeout is greater than 0, block for up to timeout milliseconds, until one of the file descriptors in fds is ready, or until a signal is caught.   Return value  -1: an error occurred. 0: the call timed out before any file descriptor became ready. A positive return value: one or more file descriptors are ready.    To read more: https://man7.org/linux/man-pages/man2/poll.2.html\nComparisons between select() and poll() Implementation details  Within the Linux kernel, select() and poll() both employ the same set of kernel-internal poll routines.  Each routine returns information about the readiness of a single file descriptor.    API differences  The use of the fd_set data type places an upper limit (FD_SETSIZE) on the range of file descriptors that can be monitored by select().  By default, this limit is 1024 on Linux, and changing it requires recompiling the application. By contrast, poll() places no intrinsic limit on the range of file descriptors that can be monitored.   Because the fd_set arguments of select() are value-result, we must reinitialize them if making repeated select() calls from within a loop. By using separate events (input) and revents (output) fields, poll() avoids this requirement.  Performance  The performance of poll() and select() is similar if either of the following is true:  The range of file descriptors to be monitored is small (i.e., the maximum file descriptor number is low). A large number of file descriptors are being monitored, but they are densely packed (i.e., most or all of the file descriptors from 0 up to some limit are being monitored).   However, the performance of select() and poll() can differ noticeably if the set of file descriptors to be monitored is sparse; that is, the maximum file descriptor number, N, is large, but only one or a few descriptors in the range 0 to N are being monitored. In this case, poll() can perform better than select().  Problems with select() and poll()  On each call to select() or poll(), the kernel must check all of the specified file descriptors to see if they are ready. In each call to select() or poll(), the program must pass a data structure to the kernel describing all of the file descriptors to be monitored, and, after checking the descriptors, the kernel returns a modified version of this data structure to the program.  For select(),  we must initialize the data structure before each call. the size of the data structure is fixed by FD_SETSIZE.   For poll(),  the size of the data structure increases with the number of file descriptors being monitored. the task of copying it from user to kernel space and back again consumes a noticeable amount of CPU time.     After the call to select() or poll(), the program must inspect every element of the returned data structure to see which file descriptors are ready.  The Linux-specific epoll API The epoll (event poll) API is a Linux-specific feature that first appeared in Linux 2.5.44.\n Features:  Allows a process or thread to monitor multiple file descriptors to see if I/O is possible on any of them (like the I/O multiplexing APIs). Provides much better performance when monitoring large numbers of file descriptors (like signal-driven I/O).    The central concept: epoll instance  An in-kernel data structure referred via an open file descriptor epfd. Can be considered as a container for two lists:  The interest list: a set of file descriptors that the process/thread has declared an interest in monitoring. The ready list: maintaining a list of file descriptors that are ready for I/O.  A subset of (or, more precisely, a set of refereces to) the interest list. Dynamically populated by the kernel as a result of I/O activity on those file descriptors.      Three system calls provided by epoll Creating an epoll instance: epoll_create() extern int epoll_create (int __size) __THROW;  Creates an epoll instance. Return:  On success: a file descriptor referring epfd to this instance. On error: -1 (and errno is set to indicate the error).   Parameters:  __size: specifying the number of file descriptors to be associated with the new instance.  Not a upper limit, but rather a hint to the kernel about how to initially dimension internal data structures. Since Linux 2.6.8, this argument is ignored (but must be greater than 0).      To read more: https://man7.org/linux/man-pages/man2/epoll_create.2.html\nModifying the epoll interest list: epoll_ctl() extern int epoll_ctl (int __epfd, int __op, int __fd, struct epoll_event *__event) __THROW;  Manipulate an epoll instance. Return:  On success: 0. On error: -1 (and errno is set to indicate the error).   Parameters:  __epfd: referred to the epoll instance to be modified. __op: specifies the operation to be performed. __fd: identifies which of the file descriptors in the interest list is to have its setting modified. __events: a pointer to a structure of type epoll_event.    To read more: https://man7.org/linux/man-pages/man2/epoll_ctl.2.html\nWaiting for events: epoll_wait() extern int epoll_wait (int __epfd, struct epoll_event *__events, int __maxevents, int __timeout);  Waits for events on the epoll instance referred to by the file descriptor __epfd. The buffer pointed to by __events is used to return information from the ready list about file descriptors in the interest list that have some events available. Return:  On success: the number of file descriptors ready for the requested I/O. On error: -1 (and errno is set to indicate the error).   Parameters:  __epfd: referred to the epoll instance. __events: a pointer to a structure of type epoll_event. __maxevents: the maximum number of events to be returned. __timeout: specifies the number of milliseconds that epoll_wait() will block.    To read more: https://man7.org/linux/man-pages/man2/epoll_wait.2.html\nDifferences between select()/poll() and epoll   Each time we call select() or poll():\n we pass a data structure to the kernel that identifies all of the file descriptors that are to be monitored. on return, the kernel passes back a data structure describing the readiness of all of theses descriptors.    With epoll:\n we use epoll_ctl() to build up a data structure in kernel space that lists the set of file descriptors to be monitored. Once this data structure has been build, each later call to epoll_wait() doesn’t need to pass any information about file descriptors to the kernel, and the call returns information about only those descriptors that are ready.    The table below shows the results (on Linux 2.6.25) when we monitor $N$ contiguous file descriptors in the range $0$ to $N - 1$ using poll(), select(), and epoll (source: The Linux Programming Interface, page 1365).\n   Number of descriptors monitored ($N$) poll() CPU time (seconds) select() CPU time (seconds) epoll CPU time (seconds)     10 0.61 0.73 0.41   100 2.9 3.0 0.42   1000 35 35 0.53   1000 990 930 0.66      It is clear that epoll is a better choice when there are a lot of file descriptors to monitor, but only a (small) part of them are active.\n   References:\n The Linux Programming Interface (Chapter 56-61, 63). Linux man pages online.   ",
  "wordCount" : "2242",
  "inLanguage": "en",
  "datePublished": "2022-03-28T00:00:00Z",
  "dateModified": "2022-03-28T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Jifan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jifan.tech/posts/2022-03-28-io-models/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jifan's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jifan.tech/imgs/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jifan.tech" accesskey="h" title="Jifan&#39;s Blog (Alt + H)">Jifan&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jifan.tech/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">












<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jifan.tech">Home</a>&nbsp;»&nbsp;<a href="https://jifan.tech/posts/">Posts</a></div>
    <h1 class="post-title">
      I/O multiplexing: select, poll and epoll
    </h1>
    <div class="post-meta"><span title='2022-03-28 00:00:00 +0000 UTC'>March 28, 2022</span>&nbsp;·&nbsp;Jifan

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#why-not-blocking-io" aria-label="Why not blocking I/O?">Why not blocking I/O?</a></li>
                <li>
                    <a href="#why-not-non-blocking-io" aria-label="Why not non-blocking I/O?">Why not non-blocking I/O?</a></li>
                <li>
                    <a href="#io-multiplexing-select--poll" aria-label="I/O multiplexing: select() &amp;amp; poll()">I/O multiplexing: <code>select()</code> &amp; <code>poll()</code></a><ul>
                        
                <li>
                    <a href="#the-select-system-call" aria-label="The select() system call">The <code>select()</code> system call</a></li>
                <li>
                    <a href="#the-poll-system-call" aria-label="The poll() system call">The <code>poll()</code> system call</a></li>
                <li>
                    <a href="#comparisons-between-select-and-poll" aria-label="Comparisons between select() and poll()">Comparisons between <code>select()</code> and <code>poll()</code></a><ul>
                        
                <li>
                    <a href="#implementation-details" aria-label="Implementation details">Implementation details</a></li>
                <li>
                    <a href="#api-differences" aria-label="API differences">API differences</a></li>
                <li>
                    <a href="#performance" aria-label="Performance">Performance</a></li></ul>
                </li>
                <li>
                    <a href="#problems-with-select-and-poll" aria-label="Problems with select() and poll()">Problems with <code>select()</code> and <code>poll()</code></a></li></ul>
                </li>
                <li>
                    <a href="#the-linux-specific-epoll-api" aria-label="The Linux-specific epoll API">The Linux-specific <em>epoll</em> API</a><ul>
                        
                <li>
                    <a href="#the-central-concept-epoll-instance" aria-label="The central concept: epoll instance">The central concept: <em>epoll</em> instance</a></li>
                <li>
                    <a href="#three-system-calls-provided-by-epoll" aria-label="Three system calls provided by epoll">Three system calls provided by <em>epoll</em></a><ul>
                        
                <li>
                    <a href="#creating-an-epoll-instance-epoll_create" aria-label="Creating an epoll instance: epoll_create()">Creating an <em>epoll</em> instance: <code>epoll_create()</code></a></li>
                <li>
                    <a href="#modifying-the-epoll-interest-list-epoll_ctl" aria-label="Modifying the epoll interest list: epoll_ctl()">Modifying the <em>epoll</em> interest list: <code>epoll_ctl()</code></a></li>
                <li>
                    <a href="#waiting-for-events-epoll_wait" aria-label="Waiting for events: epoll_wait()">Waiting for events: <code>epoll_wait()</code></a></li></ul>
                </li>
                <li>
                    <a href="#differences-between-selectpoll-and-epoll" aria-label="Differences between select()/poll() and epoll">Differences between <code>select()</code>/<code>poll()</code> and <em>epoll</em></a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p><strong>TL,DR.</strong></p>
<ul>
<li>I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them.</li>
<li>The <code>select()</code> and <code>poll()</code> are system calls to monitor file descriptors.</li>
<li>And the <em>epoll</em> is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.</li>
<li>For now, this article is merely a copy/summary of the introduction of them in man pages. Many parts of the article still need to be revised and supplemented.</li>
</ul>
</blockquote>
<h1 id="why-not-blocking-io">Why not blocking I/O?<a hidden class="anchor" aria-hidden="true" href="#why-not-blocking-io">#</a></h1>
<p>Under the conventional file I/O model, a process performs I/O on just one file descriptor, named <em><strong>fd</strong></em>, at a time, and each I/O system call blocks until the data is transferred. For example, when reading from the pipe,</p>
<ul>
<li>a <code>read()</code> call normally blocks if no data is currently present in the pipe. And,</li>
<li>a <code>write()</code> call blocks if there is insufficient space in the pipe to hold the data to be written.</li>
</ul>
<p>It&rsquo;s no doubt that the traditional blocking I/O model is already stretched when we need to monitor multiple file descriptors, or avoid blocking the current process if I/O is not possible on a file descriptor.</p>
<p>There are two direct approaches to partially address these needs:</p>
<ul>
<li>Non-blocking I/O.</li>
<li>Use of multiple processes or threads.</li>
</ul>
<p>Non-blocking I/O allows us to periodically check (&ldquo;poll&rdquo;) whether I/O is possible.
For example, we can make an input file descriptor non-blocking, and then periodically performing non-blocking reads. If we need to monitor multiple file descriptor, then we mark them all non-blocking, and poll each of them in turn.
However, polling in this manner is usually undesirable. If polling is done only infrequently, then the latency before an application responds to an I/O event may be unacceptably long; on the other hand, polling in a tight loop wastes CPU time.</p>
<!-- raw HTML omitted -->
<p>If we need to handle I/O on multiple file descriptors, we can create one child process or thread for each descriptor. To do so, however, an inter-process/thread communication mechanism is needed to inform the parent about the status of the I/O operations, which demanding more resources and can lead to programming difficulties.</p>
<p>Fortunately, modern Linux provides the following alternative I/O models.</p>
<h1 id="why-not-non-blocking-io">Why not non-blocking I/O?<a hidden class="anchor" aria-hidden="true" href="#why-not-non-blocking-io">#</a></h1>
<p>If we place a file descriptor in non-blocking mode by enabling the <code>O_NONBLOCK</code> open file status flag, then an I/O system call that can’t be immediately completed returns an error instead of blocking. Non-blocking I/O can be employed with pipes, FIFOs, sockets, terminals, pseudoterminals, and some other types of devices.</p>
<p>Non-blocking I/O allows us to periodically check (<em>“poll”</em>) whether I/O is possible on a file descriptor. If we need to monitor multiple file descriptors, then we mark them all non-blocking, and poll each of them in turn.</p>
<p>However, polling in this manner is usually undesirable. If polling is done only infrequently, then the latency before an application responds to an I/O event may be unacceptably long; on the other hand, polling in a tight loop wastes CPU time.</p>
<h1 id="io-multiplexing-select--poll">I/O multiplexing: <code>select()</code> &amp; <code>poll()</code><a hidden class="anchor" aria-hidden="true" href="#io-multiplexing-select--poll">#</a></h1>
<p>I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The <code>select()</code> and <code>poll()</code> system calls perform I/O multiplexing.</p>
<h2 id="the-select-system-call">The <code>select()</code> system call<a hidden class="anchor" aria-hidden="true" href="#the-select-system-call">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/time.h&gt; </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/select.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">FD_CLR</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span>  <span class="nf">FD_ISSET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">FD_SET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">FD_ZERO</span><span class="p">(</span><span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li><code>readfds</code>, <code>writefds</code>, and <code>exceptfds</code>: pointers to <code>file descriptor sets</code>, represented using the data type <code>fd_set</code>.
<ul>
<li><code>readfds</code>: the set of file descriptors to be tested to see if <strong>input</strong> is possible;</li>
<li><code>writefds</code>: the set of file descriptors to be tested to see if <strong>output</strong> is possible;</li>
<li><code>exceptfds</code>: the set of file descriptors to be tested to see if an <strong>exceptional condition</strong> has occurred.</li>
<li>If we are not interested in a particular class of events, then the corresponding <code>fd_set</code> argument can be specified as <code>NULL</code>.</li>
</ul>
</li>
<li>Typically, the <code>fd_set</code> data type is implemented as a bit mask (an array).
<ul>
<li>Ignoring the details, we just need to manipulate an <code>fd_set</code> with the following macros/functions:
<ul>
<li><code>FD_ZERO()</code>: initializes the set pointed to by <code>fdset</code> to be empty.</li>
<li><code>FD_SET()</code>: adds the file descriptor <code>fd</code> to the set pointed to by <code>fdset</code>.</li>
<li><code>FD_CLR()</code>: removes the file descriptor <code>fd</code> from the set pointed to by <code>fdset</code>.</li>
<li><code>FD_ISSET()</code>: returns true if the file descriptor <code>fd</code> is a member of the set pointed to by <code>fdset</code>.</li>
</ul>
</li>
<li>A file descriptor set has a maximum size, defined by the constant <code>FD_SETSIZE</code>. On Linux, this constant has the value <code>1024</code></li>
</ul>
</li>
<li>The <code>nfds</code> argument must be set one greater than the highest file descriptor number included in any of the three file descriptor sets.</li>
<li>The <code>timeout</code> argument controls the blocking behavior of <code>select()</code>
<ul>
<li>When specified as <code>NULL</code>: <code>select()</code> blocks indefinitely (until the event it is waiting for is ready).</li>
<li>Otherwise, <code>timeout</code> specifies an upper limit on the time for which <code>select()</code> is to wait.</li>
</ul>
</li>
<li>Return value
<ul>
<li>A return value of <code>–1</code> indicates that an error occurred.</li>
<li>A return value of <code>0</code> means that the call timed out before any file descriptor became ready. In this case, each of the returned file descriptor sets will be empty.</li>
<li>A positive return value indicates that one or more file descriptors is ready. The return value is the number of ready descriptors.</li>
</ul>
</li>
<li>The select() call modifies each of these structures so that, on return, they contain the set of file descriptors that are ready. (Since these structures are modified by the call, we must ensure that we reinitialize them if we are repeatedly calling <code>select()</code> from within a loop.) The structures can then be examined using <code>FD_ISSET()</code>.</li>
<li>Each time <code>select()</code> is called, these <code>fd_set</code>s are copied into the kernel, modified and returned. We need to check each bit mask (using <code>FD_ISSET()</code>) to determine which I/O events are ready.</li>
</ul>
<p><em>To read more: <a href="https://man7.org/linux/man-pages/man2/select.2.html">https://man7.org/linux/man-pages/man2/select.2.html</a></em></p>
<h2 id="the-poll-system-call">The <code>poll()</code> system call<a hidden class="anchor" aria-hidden="true" href="#the-poll-system-call">#</a></h2>
<p>The poll() system call performs a similar task to select().</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;poll.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[],</span> <span class="n">nfds_t</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li><code>fds</code>: lists the file descriptors to be monitored by <code>poll()</code>.
<ul>
<li>An array of <code>pollfd</code> structures, defined as follows:
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">pollfd</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>     <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* File descriptor */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">short</span>   <span class="n">events</span><span class="p">;</span>     <span class="cm">/* Requested events bit mask */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">short</span>   <span class="n">revents</span><span class="p">;</span>    <span class="cm">/* Returned events bit mask */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div></li>
<li>The events and revents fields of the pollfd structure are bit masks.</li>
</ul>
</li>
<li><code>nfds</code>: the number of items in the <code>fds</code> array.</li>
<li><code>timeout</code>: determines the blocking behavior of <code>poll()</code>:
<ul>
<li>If <code>timeout</code> equals <code>–1</code>, block until one of the file descriptors listed in the <code>fds</code> array is ready (as defined by the corresponding <code>events</code> field) or a signal is caught.</li>
<li>If <code>timeout</code> equals <code>0</code>, do not block (just perform a check to see which file descriptors are ready).</li>
<li>If <code>timeout</code> is greater than <code>0</code>, block for up to <code>timeout</code> milliseconds, until one of the file descriptors in fds is ready, or until a signal is caught.</li>
</ul>
</li>
<li>Return value
<ul>
<li><code>-1</code>: an error occurred.</li>
<li><code>0</code>: the call timed out before any file descriptor became ready.</li>
<li>A positive return value: one or more file descriptors are ready.</li>
</ul>
</li>
</ul>
<p><em>To read more: <a href="https://man7.org/linux/man-pages/man2/poll.2.html">https://man7.org/linux/man-pages/man2/poll.2.html</a></em></p>
<h2 id="comparisons-between-select-and-poll">Comparisons between <code>select()</code> and <code>poll()</code><a hidden class="anchor" aria-hidden="true" href="#comparisons-between-select-and-poll">#</a></h2>
<h3 id="implementation-details">Implementation details<a hidden class="anchor" aria-hidden="true" href="#implementation-details">#</a></h3>
<ul>
<li>Within the Linux kernel, <code>select()</code> and <code>poll()</code> both employ the same set of kernel-internal <em>poll</em> routines.
<ul>
<li>Each routine returns information about the readiness of a single file descriptor.</li>
</ul>
</li>
</ul>
<h3 id="api-differences">API differences<a hidden class="anchor" aria-hidden="true" href="#api-differences">#</a></h3>
<ul>
<li>The use of the <code>fd_set</code> data type places <strong>an upper limit</strong> (<code>FD_SETSIZE</code>) on the range of file descriptors that can be monitored by <code>select()</code>.
<ul>
<li>By default, this limit is <code>1024</code> on Linux, and changing it requires recompiling the application.</li>
<li>By contrast, <code>poll()</code> places no intrinsic limit on the range of file descriptors that can be monitored.</li>
</ul>
</li>
<li>Because the <code>fd_set</code> arguments of <code>select()</code> are value-result, we must reinitialize them if making repeated <code>select()</code> calls from within a loop. By using separate <code>events</code> (input) and <code>revents</code> (output) fields, <code>poll()</code> avoids this requirement.</li>
</ul>
<h3 id="performance">Performance<a hidden class="anchor" aria-hidden="true" href="#performance">#</a></h3>
<ul>
<li>The performance of <code>poll()</code> and <code>select()</code> is similar if either of the following is true:
<ul>
<li>The range of file descriptors to be monitored is small (i.e., the maximum file descriptor number is low).</li>
<li>A large number of file descriptors are being monitored, but they are densely packed (i.e., most or all of the file descriptors from 0 up to some limit are being monitored).</li>
</ul>
</li>
<li>However, the performance of <code>select()</code> and <code>poll()</code> can differ noticeably if the set of file descriptors to be monitored is sparse; that is, the maximum file descriptor number, N, is large, but only one or a few descriptors in the range 0 to N are being monitored. In this case, <code>poll()</code> can perform better than select().</li>
</ul>
<h2 id="problems-with-select-and-poll">Problems with <code>select()</code> and <code>poll()</code><a hidden class="anchor" aria-hidden="true" href="#problems-with-select-and-poll">#</a></h2>
<ul>
<li>On each call to <code>select()</code> or <code>poll()</code>, the kernel must <strong>check all of the specified file descriptors</strong> to see if they are ready.</li>
<li>In each call to <code>select()</code> or <code>poll()</code>, the program must <strong>pass a data structure to the kernel</strong> describing all of the file descriptors to be monitored, and, after checking the descriptors, the kernel <strong>returns a modified version of this data structure</strong> to the program.
<ul>
<li>For <code>select()</code>,
<ul>
<li>we must initialize the data structure before each call.</li>
<li>the size of the data structure is fixed by <code>FD_SETSIZE</code>.</li>
</ul>
</li>
<li>For <code>poll()</code>,
<ul>
<li>the size of the data structure increases with the number of file descriptors being monitored.</li>
<li>the task of copying it from user to kernel space and back again consumes a noticeable amount of CPU time.</li>
</ul>
</li>
</ul>
</li>
<li>After the call to <code>select()</code> or <code>poll()</code>, the program must inspect every element of the returned data structure to see which file descriptors are ready.</li>
</ul>
<h1 id="the-linux-specific-epoll-api">The Linux-specific <em>epoll</em> API<a hidden class="anchor" aria-hidden="true" href="#the-linux-specific-epoll-api">#</a></h1>
<p>The <em>epoll</em> (event poll) API is a Linux-specific feature that <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">first appeared in Linux 2.5.44</a>.</p>
<ul>
<li>Features:
<ul>
<li>Allows a process or thread to monitor multiple file descriptors to see if I/O is possible on any of them (like the I/O multiplexing APIs).</li>
<li>Provides much better performance when monitoring large numbers of file descriptors (like signal-driven I/O).</li>
</ul>
</li>
</ul>
<h2 id="the-central-concept-epoll-instance">The central concept: <em>epoll</em> instance<a hidden class="anchor" aria-hidden="true" href="#the-central-concept-epoll-instance">#</a></h2>
<ul>
<li>An <strong>in-kernel</strong> data structure referred via an open file descriptor <code>epfd</code>.</li>
<li>Can be considered as a container for two lists:
<ul>
<li><em>The <strong>interest</strong> list</em>: a set of file descriptors that the process/thread has declared an interest in monitoring.</li>
<li><em>The <strong>ready</strong> list</em>: maintaining a list of file descriptors that are ready for I/O.
<ul>
<li>A subset of (or, more precisely, a set of refereces to) the interest list.</li>
<li>Dynamically populated by the kernel as a result of I/O activity on those file descriptors.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="three-system-calls-provided-by-epoll">Three system calls provided by <em>epoll</em><a hidden class="anchor" aria-hidden="true" href="#three-system-calls-provided-by-epoll">#</a></h2>
<h3 id="creating-an-epoll-instance-epoll_create">Creating an <em>epoll</em> instance: <code>epoll_create()</code><a hidden class="anchor" aria-hidden="true" href="#creating-an-epoll-instance-epoll_create">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">epoll_create</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__size</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li>Creates an <em>epoll</em> instance.</li>
<li>Return:
<ul>
<li>On success: a file descriptor referring <code>epfd</code> to this instance.</li>
<li>On error: <code>-1</code> (and <code>errno</code> is set to indicate the error).</li>
</ul>
</li>
<li>Parameters:
<ul>
<li><code>__size</code>: specifying the number of file descriptors to be associated with the new instance.
<ul>
<li>Not a upper limit, but rather a hint to the kernel about how to initially dimension internal data structures.</li>
<li>Since Linux 2.6.8, this argument is ignored (but must be greater than 0).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>To read more: <a href="https://man7.org/linux/man-pages/man2/epoll_create.2.html">https://man7.org/linux/man-pages/man2/epoll_create.2.html</a></em></p>
<h3 id="modifying-the-epoll-interest-list-epoll_ctl">Modifying the <em>epoll</em> interest list: <code>epoll_ctl()</code><a hidden class="anchor" aria-hidden="true" href="#modifying-the-epoll-interest-list-epoll_ctl">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">epoll_ctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__fd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		      <span class="k">struct</span> <span class="nc">epoll_event</span> <span class="o">*</span><span class="n">__event</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li>Manipulate an epoll instance.</li>
<li>Return:
<ul>
<li>On success: <code>0</code>.</li>
<li>On error: <code>-1</code> (and <code>errno</code> is set to indicate the error).</li>
</ul>
</li>
<li>Parameters:
<ul>
<li><code>__epfd</code>: referred to the <em>epoll</em> instance to be modified.</li>
<li><code>__op</code>: specifies the operation to be performed.</li>
<li><code>__fd</code>: identifies which of the file descriptors in the interest list is to have its setting modified.</li>
<li><code>__events</code>: a pointer to a structure of type <code>epoll_event</code>.</li>
</ul>
</li>
</ul>
<p><em>To read more: <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html">https://man7.org/linux/man-pages/man2/epoll_ctl.2.html</a></em></p>
<h3 id="waiting-for-events-epoll_wait">Waiting for events: <code>epoll_wait()</code><a hidden class="anchor" aria-hidden="true" href="#waiting-for-events-epoll_wait">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">epoll_wait</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">epoll_event</span> <span class="o">*</span><span class="n">__events</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		       <span class="kt">int</span> <span class="n">__maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__timeout</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li>Waits for events on the <em>epoll</em> instance referred to by the file descriptor <code>__epfd</code>. The buffer pointed to by <code>__events</code> is used to return information from the ready list about file descriptors in the interest list that have some events available.</li>
<li>Return:
<ul>
<li>On success: the number of file descriptors ready for the requested I/O.</li>
<li>On error: <code>-1</code> (and <code>errno</code> is set to indicate the error).</li>
</ul>
</li>
<li>Parameters:
<ul>
<li><code>__epfd</code>: referred to the <em>epoll</em> instance.</li>
<li><code>__events</code>: a pointer to a structure of type <code>epoll_event</code>.</li>
<li><code>__maxevents</code>: the maximum number of events to be returned.</li>
<li><code>__timeout</code>: specifies the number of milliseconds that <code>epoll_wait()</code> will block.</li>
</ul>
</li>
</ul>
<p><em>To read more: <a href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html">https://man7.org/linux/man-pages/man2/epoll_wait.2.html</a></em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="differences-between-selectpoll-and-epoll">Differences between <code>select()</code>/<code>poll()</code> and <em>epoll</em><a hidden class="anchor" aria-hidden="true" href="#differences-between-selectpoll-and-epoll">#</a></h2>
<ul>
<li>
<p>Each time we call <code>select()</code> or <code>poll()</code>:</p>
<ul>
<li>we <strong>pass a data structure to the kernel</strong> that identifies all of the file descriptors that are to be monitored.</li>
<li>on return, <strong>the kernel passes back a data structure</strong> describing the readiness of all of theses descriptors.</li>
</ul>
</li>
<li>
<p>With <em>epoll</em>:</p>
<ul>
<li>we use <code>epoll_ctl()</code> to build up a data structure <strong>in kernel space</strong> that lists the set of file descriptors to be monitored.</li>
<li>Once this data structure has been build, each later call to <code>epoll_wait()</code> doesn&rsquo;t need to pass any information about file descriptors to the kernel, and the call returns information about <strong>only those descriptors that are ready</strong>.</li>
</ul>
</li>
<li>
<p>The table below shows the results (on Linux 2.6.25) when we monitor $N$ contiguous file descriptors in the range $0$ to $N - 1$ using <code>poll()</code>, <code>select()</code>, and <em>epoll</em> (source: <em>The Linux Programming Interface</em>, page 1365).</p>
<table>
<thead>
<tr>
<th style="text-align:center">Number of descriptors monitored ($N$)</th>
<th style="text-align:center"><code>poll()</code> CPU time (seconds)</th>
<th style="text-align:center"><code>select()</code> CPU time (seconds)</th>
<th style="text-align:center"><em>epoll</em> CPU time (seconds)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0.61</td>
<td style="text-align:center">0.73</td>
<td style="text-align:center">0.41</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">2.9</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">0.42</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">35</td>
<td style="text-align:center">35</td>
<td style="text-align:center">0.53</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">990</td>
<td style="text-align:center">930</td>
<td style="text-align:center">0.66</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>It is clear that <strong><em>epoll</em> is a better choice</strong> when there are a lot of file descriptors to monitor, but only a (small) part of them are active.</p>
</li>
</ul>
<blockquote>
<p><strong>References:</strong></p>
<ul>
<li><a href="https://man7.org/tlpi/"><em>The Linux Programming Interface</em></a> (Chapter 56-61, 63).</li>
<li><a href="https://man7.org/linux/man-pages/index.html">Linux man pages online</a>.</li>
</ul>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://jifan.tech">Jifan&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js" integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            
            throwOnError : false
        });
    });
</script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>