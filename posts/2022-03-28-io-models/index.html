<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>I/O multiplexing: select, poll and epoll | Jifan&#39;s Blog</title>
<meta name="keywords" content="Linux, I/O" />
<meta name="description" content="TL,DR.
 I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.   Why not blocking I/O? Under the conventional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred.">
<meta name="author" content="Jifan">
<link rel="canonical" href="https://jifan.tech/posts/2022-03-28-io-models/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d2d913f96f20672531467f8a00a1afae6af2b44b8ba24b7a5cab31330f0bcb2c.css" integrity="sha256-0tkT&#43;W8gZyUxRn&#43;KAKGvrmrytEuLokt6XKsxMw8Lyyw=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://jifan.tech/imgs/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jifan.tech/imgs/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jifan.tech/imgs/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jifan.tech/imgs/apple-touch-icon.png">
<link rel="mask-icon" href="https://jifan.tech/imgs/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="I/O multiplexing: select, poll and epoll" />
<meta property="og:description" content="TL,DR.
 I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.   Why not blocking I/O? Under the conventional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jifan.tech/posts/2022-03-28-io-models/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-28T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-03-28T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="I/O multiplexing: select, poll and epoll"/>
<meta name="twitter:description" content="TL,DR.
 I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.   Why not blocking I/O? Under the conventional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://jifan.tech/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "I/O multiplexing: select, poll and epoll",
      "item": "https://jifan.tech/posts/2022-03-28-io-models/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "I/O multiplexing: select, poll and epoll",
  "name": "I\/O multiplexing: select, poll and epoll",
  "description": "TL,DR.\n I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.   Why not blocking I/O? Under the conventional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred.",
  "keywords": [
    "Linux", "I/O"
  ],
  "articleBody": " TL,DR.\n I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() are system calls to monitor file descriptors. And the epoll is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.   Why not blocking I/O? Under the conventional file I/O model, a process performs I/O on just one file descriptor, named fd, at a time, and each I/O system call blocks until the data is transferred. For example, when reading from the pipe,\n a read() call normally blocks if no data is currently present in the pipe. And, a write() call blocks if there is insufficient space in the pipe to hold the data to be written.  It’s no doubt that the traditional blocking I/O model is already stretched when we need to monitor multiple file descriptors, or avoid blocking the current process if I/O is not possible on a file descriptor.\nThere are two direct approaches to partially address these needs:\n Non-blocking I/O. Use of multiple processes or threads.  Non-blocking I/O allows us to periodically check (“poll”) whether I/O is possible. For example, we can make an input file descriptor non-blocking, and then periodically performing non-blocking reads. If we need to monitor multiple file descriptor, then we mark them all non-blocking, and poll each of them in turn. However, polling in this manner is usually undesirable. If polling is done only infrequently, then the latency before an application responds to an I/O event may be unacceptably long; on the other hand, polling in a tight loop wastes CPU time.\nIf we need to handle I/O on multiple file descriptors, we can create one child process or thread for each descriptor. To do so, however, an inter-process/thread communication mechanism is needed to inform the parent about the status of the I/O operations, which demanding more resources and can lead to programming difficulties.\nFortunately, modern Linux provides the following alternative I/O models.\nWhy not non-blocking I/O? ……\nI/O multiplexing: select() \u0026 poll() I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The select() and poll() system calls perform I/O multiplexing.\nThe Linux-specific epoll API The epoll (event poll) API is a Linux-specific feature that first appeared in Linux 2.6 (?).\n Features:  Allows a process or thread to monitor multiple file descriptors to see if I/O is possible on any of them (like the I/O multiplexing APIs). Provides much better performance when monitoring large numbers of file descriptors (like signal-driven I/O).    The central concept: epoll instance  An in-kernel data structure referred via an open file descriptor epfd. Can be considered as a container for two lists:  The interest list: a set of file descriptors that the process/thread has declared an interest in monitoring. The ready list: maintaining a list of file descriptors that are ready for I/O.  A subset of (or, more precisely, a set of refereces to) the interest list. Dynamically populated by the kernel as a result of I/O activity on those file descriptors.      Three system calls provided by epoll Creating an epoll instance: epoll_create() extern int epoll_create (int __size) __THROW;  Creates an epoll instance. Return:  On success: a file descriptor referring epfd to this instance. On error: -1 (and errno is set to indicate the error).   Parameters:  __size: specifying the number of file descriptors to be associated with the new instance.  Not a upper limit, but rather a hint to the kernel about how to initially dimension internal data structures. Since Linux 2.6.8, this argument is ignored (but must be greater than 0).      To read more: https://man7.org/linux/man-pages/man2/epoll_create.2.html\nModifying the epoll interest list: epoll_ctl() extern int epoll_ctl (int __epfd, int __op, int __fd, struct epoll_event *__event) __THROW;  Manipulate an epoll instance. Return:  On success: 0. On error: -1 (and errno is set to indicate the error).   Parameters:  __epfd: referred to the epoll instance to be modified. __op: specifies the operation to be performed. __fd: identifies which of the file descriptors in the interest list is to have its setting modified. __events: a pointer to a structure of type epoll_event.    To read more: https://man7.org/linux/man-pages/man2/epoll_ctl.2.html\nWaiting for events: epoll_wait() extern int epoll_wait (int __epfd, struct epoll_event *__events, int __maxevents, int __timeout);  Waits for events on the epoll instance referred to by the file descriptor __epfd. The buffer pointed to by __events is used to return information from the ready list about file descriptors in the interest list that have some events available. Return:  On success: the number of file descriptors ready for the requested I/O. On error: -1 (and errno is set to indicate the error).   Parameters:  __epfd: referred to the epoll instance. __events: a pointer to a structure of type epoll_event. __maxevents: the maximum number of events to be returned. __timeout: specifies the number of milliseconds that epoll_wait() will block.    To read more: https://man7.org/linux/man-pages/man2/epoll_wait.2.html\nEvent notification mode: LT and ET ……\nComparisons Differences between select() and poll() ……\nDifferences between select(), poll() and epoll   Each time we call select() or poll():\n we pass a data structure to the kernel that identifies all of the file descriptors that are to be monitored. on return, the kernel passes back a data structure describing the readiness of all of theses descriptors.    With epoll:\n we use epoll_ctl() to build up a data structure in kernel space that lists the set of file descriptors to be monitored. Once this data structure has been build, each later call to epoll_wait() doesn’t need to pass any information about file descriptors to the kernel, and the call returns information about only those descriptors that are ready.    The table below shows the results (on Linux 2.6.25) when we monitor $N$ contiguous file descriptors in the range $0$ to $N - 1$ using poll(), select(), and epoll (source: The Linux Programming Interface, page 1365).\n   Number of descriptors monitored ($N$) poll() CPU time (seconds) select() CPU time (seconds) epoll CPU time (seconds)     10 0.61 0.73 0.41   100 2.9 3.0 0.42   1000 35 35 0.53   1000 990 930 0.66      It is clear that epoll is a better choice when there are a lot of file descriptors to monitor, but only a (small) part of them are active.\n   References:\n The Linux Programming Interface (Chapter 56-61, 63). Linux man pages online   ",
  "wordCount" : "1055",
  "inLanguage": "en",
  "datePublished": "2022-03-28T00:00:00Z",
  "dateModified": "2022-03-28T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Jifan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jifan.tech/posts/2022-03-28-io-models/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jifan's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jifan.tech/imgs/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jifan.tech" accesskey="h" title="Jifan&#39;s Blog (Alt + H)">Jifan&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jifan.tech/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://jifan.tech/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">












<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jifan.tech">Home</a>&nbsp;»&nbsp;<a href="https://jifan.tech/posts/">Posts</a></div>
    <h1 class="post-title">
      I/O multiplexing: select, poll and epoll<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h1>
    <div class="post-meta"><span title='2022-03-28 00:00:00 +0000 UTC'>March 28, 2022</span>&nbsp;·&nbsp;Jifan

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#why-not-blocking-io" aria-label="Why not blocking I/O?">Why not blocking I/O?</a></li>
                <li>
                    <a href="#why-not-non-blocking-io" aria-label="Why not non-blocking I/O?">Why not non-blocking I/O?</a></li>
                <li>
                    <a href="#io-multiplexing-select--poll" aria-label="I/O multiplexing: select() &amp;amp; poll()">I/O multiplexing: <code>select()</code> &amp; <code>poll()</code></a></li>
                <li>
                    <a href="#the-linux-specific-epoll-api" aria-label="The Linux-specific epoll API">The Linux-specific <em>epoll</em> API</a><ul>
                        
                <li>
                    <a href="#the-central-concept-epoll-instance" aria-label="The central concept: epoll instance">The central concept: <em>epoll</em> instance</a></li>
                <li>
                    <a href="#three-system-calls-provided-by-epoll" aria-label="Three system calls provided by epoll">Three system calls provided by <em>epoll</em></a><ul>
                        
                <li>
                    <a href="#creating-an-epoll-instance-epoll_create" aria-label="Creating an epoll instance: epoll_create()">Creating an <em>epoll</em> instance: <code>epoll_create()</code></a></li>
                <li>
                    <a href="#modifying-the-epoll-interest-list-epoll_ctl" aria-label="Modifying the epoll interest list: epoll_ctl()">Modifying the <em>epoll</em> interest list: <code>epoll_ctl()</code></a></li>
                <li>
                    <a href="#waiting-for-events-epoll_wait" aria-label="Waiting for events: epoll_wait()">Waiting for events: <code>epoll_wait()</code></a></li>
                <li>
                    <a href="#event-notification-mode-lt-and-et" aria-label="Event notification mode: LT and ET">Event notification mode: LT and ET</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#comparisons" aria-label="Comparisons">Comparisons</a><ul>
                        
                <li>
                    <a href="#differences-between-select-and-poll" aria-label="Differences between select() and poll()">Differences between <code>select()</code> and <code>poll()</code></a></li>
                <li>
                    <a href="#differences-between-select-poll-and-epoll" aria-label="Differences between select(), poll() and epoll">Differences between <code>select()</code>, <code>poll()</code> and <em>epoll</em></a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p><strong>TL,DR.</strong></p>
<ul>
<li>I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them.</li>
<li>The <code>select()</code> and <code>poll()</code> are system calls to monitor file descriptors.</li>
<li>And the <em>epoll</em> is a Linux-specified API to implement I/O multiplexing with higher performance when it comes to large numbers of file descriptors.</li>
</ul>
</blockquote>
<h1 id="why-not-blocking-io">Why not blocking I/O?<a hidden class="anchor" aria-hidden="true" href="#why-not-blocking-io">#</a></h1>
<p>Under the conventional file I/O model, a process performs I/O on just one file descriptor, named <em><strong>fd</strong></em>, at a time, and each I/O system call blocks until the data is transferred. For example, when reading from the pipe,</p>
<ul>
<li>a <code>read()</code> call normally blocks if no data is currently present in the pipe. And,</li>
<li>a <code>write()</code> call blocks if there is insufficient space in the pipe to hold the data to be written.</li>
</ul>
<p>It&rsquo;s no doubt that the traditional blocking I/O model is already stretched when we need to monitor multiple file descriptors, or avoid blocking the current process if I/O is not possible on a file descriptor.</p>
<p>There are two direct approaches to partially address these needs:</p>
<ul>
<li>Non-blocking I/O.</li>
<li>Use of multiple processes or threads.</li>
</ul>
<p>Non-blocking I/O allows us to periodically check (&ldquo;poll&rdquo;) whether I/O is possible.
For example, we can make an input file descriptor non-blocking, and then periodically performing non-blocking reads. If we need to monitor multiple file descriptor, then we mark them all non-blocking, and poll each of them in turn.
However, polling in this manner is usually undesirable. If polling is done only infrequently, then the latency before an application responds to an I/O event may be unacceptably long; on the other hand, polling in a tight loop wastes CPU time.</p>
<!-- raw HTML omitted -->
<p>If we need to handle I/O on multiple file descriptors, we can create one child process or thread for each descriptor. To do so, however, an inter-process/thread communication mechanism is needed to inform the parent about the status of the I/O operations, which demanding more resources and can lead to programming difficulties.</p>
<p>Fortunately, modern Linux provides the following alternative I/O models.</p>
<h1 id="why-not-non-blocking-io">Why not non-blocking I/O?<a hidden class="anchor" aria-hidden="true" href="#why-not-non-blocking-io">#</a></h1>
<p>……</p>
<h1 id="io-multiplexing-select--poll">I/O multiplexing: <code>select()</code> &amp; <code>poll()</code><a hidden class="anchor" aria-hidden="true" href="#io-multiplexing-select--poll">#</a></h1>
<p>I/O multiplexing allows a process to simultaneously monitor multiple file descriptors to find out whether I/O is possible on any of them. The <code>select()</code> and <code>poll()</code> system calls perform I/O multiplexing.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h1 id="the-linux-specific-epoll-api">The Linux-specific <em>epoll</em> API<a hidden class="anchor" aria-hidden="true" href="#the-linux-specific-epoll-api">#</a></h1>
<p>The <em>epoll</em> (event poll) API is a Linux-specific feature that first appeared in Linux 2.6 (?).</p>
<ul>
<li>Features:
<ul>
<li>Allows a process or thread to monitor multiple file descriptors to see if I/O is possible on any of them (like the I/O multiplexing APIs).</li>
<li>Provides much better performance when monitoring large numbers of file descriptors (like signal-driven I/O).</li>
</ul>
</li>
</ul>
<h2 id="the-central-concept-epoll-instance">The central concept: <em>epoll</em> instance<a hidden class="anchor" aria-hidden="true" href="#the-central-concept-epoll-instance">#</a></h2>
<ul>
<li>An <strong>in-kernel</strong> data structure referred via an open file descriptor <code>epfd</code>.</li>
<li>Can be considered as a container for two lists:
<ul>
<li><em>The <strong>interest</strong> list</em>: a set of file descriptors that the process/thread has declared an interest in monitoring.</li>
<li><em>The <strong>ready</strong> list</em>: maintaining a list of file descriptors that are ready for I/O.
<ul>
<li>A subset of (or, more precisely, a set of refereces to) the interest list.</li>
<li>Dynamically populated by the kernel as a result of I/O activity on those file descriptors.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="three-system-calls-provided-by-epoll">Three system calls provided by <em>epoll</em><a hidden class="anchor" aria-hidden="true" href="#three-system-calls-provided-by-epoll">#</a></h2>
<h3 id="creating-an-epoll-instance-epoll_create">Creating an <em>epoll</em> instance: <code>epoll_create()</code><a hidden class="anchor" aria-hidden="true" href="#creating-an-epoll-instance-epoll_create">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">epoll_create</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__size</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li>Creates an <em>epoll</em> instance.</li>
<li>Return:
<ul>
<li>On success: a file descriptor referring <code>epfd</code> to this instance.</li>
<li>On error: <code>-1</code> (and <code>errno</code> is set to indicate the error).</li>
</ul>
</li>
<li>Parameters:
<ul>
<li><code>__size</code>: specifying the number of file descriptors to be associated with the new instance.
<ul>
<li>Not a upper limit, but rather a hint to the kernel about how to initially dimension internal data structures.</li>
<li>Since Linux 2.6.8, this argument is ignored (but must be greater than 0).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>To read more: <a href="https://man7.org/linux/man-pages/man2/epoll_create.2.html">https://man7.org/linux/man-pages/man2/epoll_create.2.html</a></em></p>
<h3 id="modifying-the-epoll-interest-list-epoll_ctl">Modifying the <em>epoll</em> interest list: <code>epoll_ctl()</code><a hidden class="anchor" aria-hidden="true" href="#modifying-the-epoll-interest-list-epoll_ctl">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">epoll_ctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__fd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		      <span class="k">struct</span> <span class="nc">epoll_event</span> <span class="o">*</span><span class="n">__event</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li>Manipulate an epoll instance.</li>
<li>Return:
<ul>
<li>On success: <code>0</code>.</li>
<li>On error: <code>-1</code> (and <code>errno</code> is set to indicate the error).</li>
</ul>
</li>
<li>Parameters:
<ul>
<li><code>__epfd</code>: referred to the <em>epoll</em> instance to be modified.</li>
<li><code>__op</code>: specifies the operation to be performed.</li>
<li><code>__fd</code>: identifies which of the file descriptors in the interest list is to have its setting modified.</li>
<li><code>__events</code>: a pointer to a structure of type <code>epoll_event</code>.</li>
</ul>
</li>
</ul>
<p><em>To read more: <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html">https://man7.org/linux/man-pages/man2/epoll_ctl.2.html</a></em></p>
<h3 id="waiting-for-events-epoll_wait">Waiting for events: <code>epoll_wait()</code><a hidden class="anchor" aria-hidden="true" href="#waiting-for-events-epoll_wait">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">epoll_wait</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">epoll_event</span> <span class="o">*</span><span class="n">__events</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		       <span class="kt">int</span> <span class="n">__maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__timeout</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li>Waits for events on the <em>epoll</em> instance referred to by the file descriptor <code>__epfd</code>. The buffer pointed to by <code>__events</code> is used to return information from the ready list about file descriptors in the interest list that have some events available.</li>
<li>Return:
<ul>
<li>On success: the number of file descriptors ready for the requested I/O.</li>
<li>On error: <code>-1</code> (and <code>errno</code> is set to indicate the error).</li>
</ul>
</li>
<li>Parameters:
<ul>
<li><code>__epfd</code>: referred to the <em>epoll</em> instance.</li>
<li><code>__events</code>: a pointer to a structure of type <code>epoll_event</code>.</li>
<li><code>__maxevents</code>: the maximum number of events to be returned.</li>
<li><code>__timeout</code>: specifies the number of milliseconds that <code>epoll_wait()</code> will block.</li>
</ul>
</li>
</ul>
<p><em>To read more: <a href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html">https://man7.org/linux/man-pages/man2/epoll_wait.2.html</a></em></p>
<h3 id="event-notification-mode-lt-and-et">Event notification mode: LT and ET<a hidden class="anchor" aria-hidden="true" href="#event-notification-mode-lt-and-et">#</a></h3>
<p>……</p>
<h1 id="comparisons">Comparisons<a hidden class="anchor" aria-hidden="true" href="#comparisons">#</a></h1>
<h2 id="differences-between-select-and-poll">Differences between <code>select()</code> and <code>poll()</code><a hidden class="anchor" aria-hidden="true" href="#differences-between-select-and-poll">#</a></h2>
<p>……</p>
<h2 id="differences-between-select-poll-and-epoll">Differences between <code>select()</code>, <code>poll()</code> and <em>epoll</em><a hidden class="anchor" aria-hidden="true" href="#differences-between-select-poll-and-epoll">#</a></h2>
<ul>
<li>
<p>Each time we call <code>select()</code> or <code>poll()</code>:</p>
<ul>
<li>we <strong>pass a data structure to the kernel</strong> that identifies all of the file descriptors that are to be monitored.</li>
<li>on return, <strong>the kernel passes back a data structure</strong> describing the readiness of all of theses descriptors.</li>
</ul>
</li>
<li>
<p>With <em>epoll</em>:</p>
<ul>
<li>we use <code>epoll_ctl()</code> to build up a data structure <strong>in kernel space</strong> that lists the set of file descriptors to be monitored.</li>
<li>Once this data structure has been build, each later call to <code>epoll_wait()</code> doesn&rsquo;t need to pass any information about file descriptors to the kernel, and the call returns information about <strong>only those descriptors that are ready</strong>.</li>
</ul>
</li>
<li>
<p>The table below shows the results (on Linux 2.6.25) when we monitor $N$ contiguous file descriptors in the range $0$ to $N - 1$ using <code>poll()</code>, <code>select()</code>, and <em>epoll</em> (source: <em>The Linux Programming Interface</em>, page 1365).</p>
<table>
<thead>
<tr>
<th style="text-align:center">Number of descriptors monitored ($N$)</th>
<th style="text-align:center"><code>poll()</code> CPU time (seconds)</th>
<th style="text-align:center"><code>select()</code> CPU time (seconds)</th>
<th style="text-align:center"><em>epoll</em> CPU time (seconds)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0.61</td>
<td style="text-align:center">0.73</td>
<td style="text-align:center">0.41</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">2.9</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">0.42</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">35</td>
<td style="text-align:center">35</td>
<td style="text-align:center">0.53</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">990</td>
<td style="text-align:center">930</td>
<td style="text-align:center">0.66</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>It is clear that <strong><em>epoll</em> is a better choice</strong> when there are a lot of file descriptors to monitor, but only a (small) part of them are active.</p>
</li>
</ul>
<blockquote>
<p><strong>References:</strong></p>
<ul>
<li><a href="https://man7.org/tlpi/"><em>The Linux Programming Interface</em></a> (Chapter 56-61, 63).</li>
<li><a href="https://man7.org/linux/man-pages/index.html">Linux man pages online</a></li>
</ul>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://jifan.tech">Jifan&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js" integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            
            throwOnError : false
        });
    });
</script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>